<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>进程与进程管理 | SliverHorn的博客</title><meta property="og:title" content="进程与进程管理 - SliverHorn的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2022-11-16T17:05:19+08:00"><meta property="article:modified_time" content="2022-11-16T17:05:19+08:00"><meta name=Keywords content="golang,SliverHorn,gin-vue-admin,gf-vue-admin
"><meta name=description content="进程与进程管理"><meta name=author content="SliverHorn"><meta property="og:url" content="https://sliverhorn.com/operating_system/2/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet><link rel=stylesheet href=/css/douban.css><link rel=stylesheet href=/css/other.css></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://sliverhorn.com>SliverHorn的博客</a><p class=description>Golang 开发</p></div><div><nav id=nav-menu class=clearfix><a href=https://sliverhorn.com>首页</a>
<a href=https://sliverhorn.com/linux/ title=linux>linux</a>
<a href=https://sliverhorn.com/higher_mathematics/ title=高等数学>高等数学</a>
<a href=https://sliverhorn.com/data_structure/ title=数据结构>数据结构</a>
<a href=https://sliverhorn.com/tool/ title=工具>工具</a>
<a href=https://sliverhorn.com/archives/ title=归档>归档</a>
<a href=https://sliverhorn.com/about/ title=关于>关于</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><style type=text/css>.post-toc{position:fixed;width:200px;margin-left:-210px;padding:5px 10px;font-family:Athelas,STHeiti,Microsoft Yahei,serif;font-size:12px;border:1px solid rgba(0,0,0,7%);border-radius:5px;background-color:rgba(255,255,255,.98);background-clip:padding-box;-webkit-box-shadow:1px 1px 2px rgba(0,0,0,.125);box-shadow:1px 1px 2px rgba(0,0,0,.125);word-wrap:break-word;white-space:nowrap;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:999;cursor:pointer;max-height:70%;overflow-y:auto;overflow-x:hidden}.post-toc .post-toc-title{width:100%;margin:0 auto;font-size:20px;font-weight:400;text-transform:uppercase;text-align:center}.post-toc .post-toc-content{font-size:15px}.post-toc .post-toc-content>nav>ul{margin:10px 0}.post-toc .post-toc-content ul{padding-left:20px;list-style:square;margin:.5em;line-height:1.8em}.post-toc .post-toc-content ul ul{padding-left:15px;display:none}@media print,screen and (max-width:1057px){.post-toc{display:none}}</style><div class=post-toc style=position:absolute;top:188px><h2 class=post-toc-title>文章目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#前驱图>前驱图</a></li><li><a href=#进程基本概念>进程基本概念</a><ul><li><a href=#进程控制块pcb>进程控制块（PCB）</a></li></ul></li><li><a href=#进程的基本状态>进程的基本状态</a></li><li><a href=#进程的控制>进程的控制</a></li><li><a href=#进程状态转换的过程>进程状态转换的过程</a></li><li><a href=#进程通信>进程通信</a></li><li><a href=#线程>线程</a><ul><li><a href=#线程的优缺点>线程的优缺点</a></li></ul></li><li><a href=#进程与程序的区别>进程与程序的区别</a></li><li><a href=#进程和线程的主要区别>进程和线程的主要区别</a></li></ul><ul><li><a href=#调用的基本概念>调用的基本概念</a></li><li><a href=#衡量调度算法的性能指标>衡量调度算法的性能指标</a></li><li><a href=#进程调度的时机>进程调度的时机</a></li><li><a href=#进程调度的任务与方式>进程调度的任务与方式</a><ul><li><a href=#进程调度的任务>进程调度的任务</a></li><li><a href=#进程调度的方式>进程调度的方式</a></li></ul></li><li><a href=#经典调度算法>经典调度算法</a><ul><li><a href=#先来先服务调度算法fcfs>先来先服务调度算法（FCFS）</a></li><li><a href=#短作业优先调度算法sjf>短作业优先调度算法（SJF）</a></li><li><a href=#高响应比优先调度算法hrrn>高响应比优先调度算法（HRRN）</a></li><li><a href=#时间片轮转调度算法rr>时间片轮转调度算法（RR）</a></li><li><a href=#优先级调度算法pas>优先级调度算法（PAS）</a></li><li><a href=#多级反馈队列调度算法mfq>多级反馈队列调度算法（MFQ）</a></li><li><a href=#经典调度算法总结>经典调度算法总结</a></li></ul></li><li><a href=#上下文及其切换机制>上下文及其切换机制</a></li></ul><ul><li><a href=#互斥和同步>互斥和同步</a></li><li><a href=#互斥实现方法>互斥实现方法</a><ul><li><a href=#软件实现法>软件实现法</a></li></ul></li><li><a href=#信号量semaphore机制>信号量（Semaphore）机制</a></li><li><a href=#经典同步问题>经典同步问题</a><ul><li><a href=#生产者-消费者问题>生产者-消费者问题</a></li><li><a href=#读者-写者问题>读者-写者问题</a></li><li><a href=#哲学家进餐问题>哲学家进餐问题</a></li></ul></li></ul><ul><li><a href=#死锁的基本概念>死锁的基本概念</a></li><li><a href=#死锁的处理方法>死锁的处理方法</a><ul><li><a href=#预防死锁>预防死锁</a></li><li><a href=#死锁避免>死锁避免</a></li><li><a href=#死锁检测>死锁检测</a></li><li><a href=#死锁解锁>死锁解锁</a></li></ul></li></ul></nav></div></div><script type=text/javascript>$(document).ready(function(){if(e=$(".post-toc"),e.length){t=$("#main").offset().left,t<220&&e.css({width:t-10,"margin-left":0-t});var e,t,n=e.offset().top-20,s={start:{position:"absolute",top:n},process:{position:"fixed",top:20}};$(window).scroll(function(){var t=$(window).scrollTop();t<n?e.css(s.start):e.css(s.process)})}$("#TableOfContents").children().length<1&&$(".post-toc").remove()})</script><article class=post><header><h1 class=post-title>进程与进程管理</h1></header><date class="post-meta meta-date">2022年11月16日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><h1 id=进程与线程>进程与线程</h1><h2 id=前驱图>前驱图</h2><p>​ <strong>前驱图</strong>：是指一个有向无循环图，用于描述<strong>进程</strong>之间执行的<strong>先后循序</strong>。</p><p><a data-fancybox=gallery href=/operating_system/2.png><img class=mx-auto alt=前驱图 src=/operating_system/2.png></a></p><ol><li>程序<strong>顺序执行</strong>时的特征：<ol><li>顺序性</li><li>封闭性</li><li>可再现性</li></ol></li><li>程序<strong>并发执行</strong>时的特征<ol><li>间断性</li><li>时区封闭性</li><li>不可再现性</li></ol></li></ol><blockquote><p>封闭性：是指程序运行在一个封闭的环境中，即程序运行时独占系统的全部资源，这些资源的状态只能因程序的执行而改变，不受任何外界因素的影响。</p></blockquote><p>所以引入进程，便于更好地描述和控制程序的并发执行，实现<strong>资源共享</strong>。</p><h2 id=进程基本概念>进程基本概念</h2><p>​ 进程：是进程实体的运行过程，是系统进行<strong>资源分配和调度</strong>的一个独立单位。</p><p><strong>进程的特征</strong>：</p><ul><li><strong>动态性</strong>：进程是程序在处理器上的一次执行过程，因而是动态的（动态性是进程的<strong>最基本的特征</strong>）</li><li><strong>并发性</strong>：指多个进程实体同时存于内存中，能在一段时间内同时运行</li><li><strong>独立性</strong>：是指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位</li><li><strong>异步性</strong>：进程按照各自独立运行的、不可预知的速度向前推荐。</li><li><strong>结构性</strong>：从结构上看，进程实体是由程序段、数据段和进程控制块 （PCB）三部分组成的。</li></ul><blockquote><p>程序段：是指程序的代码</p><p>数据段：是指运行过程中产生的各种数据</p></blockquote><h3 id=进程控制块pcb>进程控制块（PCB）</h3><p>​ <strong>PCB</strong>：是进程实体的重要组成部分，其中记录了用于描述<strong>进程情况</strong>及<strong>控制进程运行所需要的全部信息</strong>。通过PCB使得原来不能并发执行的程序，<strong>成为能并发执行的进程</strong>。在进程的控制和管理中，随进程的创建而建立PCB，因进程的状态变化而修改PCB的相关内容；当进程被撤销时，系统收回其PCB。可见，系统是根据PCB来<strong>感知进程</strong>的存在的，PCB是<strong>进程存在的唯一标志</strong>，一个进程只能有一个进程控制块。</p><table><thead><tr><th>进程标识符</th><th>处理机状态</th><th>进程调度信息</th><th>进程控制信息</th><th>家族联系信息</th></tr></thead><tbody><tr><td>内部标识</td><td>通用寄存器</td><td>进程状态</td><td>程序和数据的地址</td><td>用于说明本进程与其他家族成员间的关系</td></tr><tr><td>内部标识</td><td>指令计数器</td><td>进程优先级</td><td>进程同步和通信机</td><td>用于说明本进程与其他家族成员间的关系</td></tr><tr><td>外部标识</td><td>程序状态字</td><td>进程调度所需的其他信息</td><td>资源清单</td><td>用于说明本进程与其他家族成员间的关系</td></tr><tr><td>外部标识</td><td>用户栈指针</td><td>事件</td><td>链接指针</td><td>用于说明本进程与其他家族成员间的关系</td></tr></tbody></table><h4 id=进程控制块的组织方式>进程控制块的组织方式</h4><p><a data-fancybox=gallery href=/operating_system/3.png><img class=mx-auto alt=进程控制块的组织方式 src=/operating_system/3.png></a></p><table><thead><tr><th>方式</th><th>描述</th></tr></thead><tbody><tr><td>线性方式</td><td>将系统中所有的PCB都组织在一张线性表。该方式实现简单、开销小。但每次查找时都需要扫描整张表，因此适合进程数目不多的系统。</td></tr><tr><td>链接方式</td><td>即把具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列。</td></tr><tr><td>索引方式</td><td>系统根据所有进程状态的不同，建立几张索引表。</td></tr></tbody></table><h2 id=进程的基本状态>进程的基本状态</h2><p>​ 进程有三种基本状态：就绪状态、执行状态、阻塞（等待）状态</p><p><a data-fancybox=gallery href=/operating_system/4.png><img class=mx-auto alt=进程的基本状态 src=/operating_system/4.png></a></p><p>引起进程阻塞和唤醒的事件：</p><ol><li>请求资源失败</li><li>待某操作完成</li><li>数据未到达</li><li>待任务到达</li></ol><p>引起创建进程的事件：</p><ol><li>用户登录</li><li>作业调度</li><li>请求服务</li><li>应用请求</li></ol><p>引起删除进程的事件：</p><ol><li>正常结束</li><li>异常结束</li><li>外界干预</li></ol><blockquote><p>进程状态间如何转换？</p><p>引起进程状态转换的经典事件：</p><ol><li>就绪 -> 执行</li><li>执行 -> 就绪</li><li>执行 -> 阻塞</li><li>阻塞 -> 就绪</li></ol></blockquote><h2 id=进程的控制>进程的控制</h2><p>​ 进程的控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新的进程、撤销已有进程、实现进程准备状态转换等功能。</p><p>​ 用原语实现进程控制。原语的特点就是执行期间不允许中断，只能一气呵成。这种不可被中断的操作即原子操作。原语采用开中断指令和关中断指令实现。</p><ul><li>进程创建原语：create/fork/vfork</li><li>进程终止原语：exit/terminate/_exit</li><li>阻塞原语：block/wait</li><li>唤醒原语：wakeup</li><li>挂起原语：susped/sleep</li><li>激活原语：active</li></ul><p><a data-fancybox=gallery href=/operating_system/5.png><img class=mx-auto alt=进程的控制 src=/operating_system/5.png></a></p><h2 id=进程状态转换的过程>进程状态转换的过程</h2><ol><li>进程创建过程<ol><li>申请PCB：赋予一个同意进程标识符</li><li>分配资源：为进程映像分配空间</li><li>初始化进程控制块：初始化标识信息、CPU状态信息、进程状态信息等</li><li>将进程插入就绪队列：设置相应的链接，把新进程加到就绪队列的链表中</li></ol></li><li>进程的终止过程<ol><li>找到要终止进程的PCB，读取进程的状态</li><li>立刻终止</li><li>终止其所有子进程</li><li>释放资源</li><li>将PCB移除队列，等待其他进程来搜索信息</li></ol></li><li>过程阻塞过程<ol><li>进程停止执行、保存CPU现场</li><li>改变状态</li><li>插入相应阻塞队列</li><li>调度进程重新调度</li></ol></li></ol><h2 id=进程通信>进程通信</h2><p>​ 进程通信是指进程之间的信息交换。目前，高级通信机制可归纳结为四大类：<strong>共享存储器系统</strong>、<strong>管道通信系统</strong>、<strong>消息传递系统</strong>以及客户机——服务器系统</p><ol><li><p><strong>共享存储器</strong>：在内存中分配一片空间作为共享存储区。需要进行通信的进程把它附加到自己的地址空间中，不需要则把它取消。共享存储器系统分两种：</p><ol><li>基于<strong>共享数据结构</strong>的通信方式：在这种通信方式中，要求诸进程公用某些数据结构，借以实现诸进程间的信息交换。操作系统仅提供共享存储器，由<strong>程序员负责</strong>对公用数据结构的设置及对进程间同步的处理。该通信方式仅适于<strong>传递少量数据</strong>，<strong>通信效率低下</strong>，属于<strong>低级通信</strong>。</li><li>基于<strong>共享存储区</strong>的通信方式：为了传输<strong>大量数据</strong>，在内存中划出一块共享存储区域，诸进程可通过对该共享区的读或写交换信息，实现通信，数据的形式和位置甚至访问控制都是<strong>由进程负责</strong>，而不是OS。该通信方式属于<strong>高级通信</strong>。</li></ol></li><li><p><strong>管道通信系统</strong>：管道（pipe文件）：是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件。由于发送进程和接收进程是利用管道进行通信的，故有称为管道通信。这种方式首创于UNIX系统，由于它能有效地传送大量数据，因而又被引入到其他操作系统中。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：</p><ol><li><strong>互斥</strong>：即当一个进程正在对pipe执行读/写操作时，其他进程必须等待。</li><li><strong>同步</strong>：把一定数量的数据写入pipe，便去睡眠等待，直到读进程取走数据后再把它唤醒。当读进程读一空pipe时，也应睡眠等待，直到写进程将数据写入管道后才能将之唤醒。</li><li>确认对方是否<strong>存在</strong>：只要确定了对方已存在时才能进行通信。</li></ol></li><li><p><strong>消息传递系统</strong>：在该机制中，进程<strong>不必借助任何存储区</strong>或数据结构，而是<strong>以格式化的消息为单位</strong>，将通信的<strong>数据封装在消息中</strong>，并利用操作系统提供一组通信命令（原语），在进程间进行消息传递，完成<strong>进程间的数据交换</strong>。该方式隐藏了通信实现细节，使通信过程对用户透明化，降低了通信程序设计的复杂性和错误率称为当前应用最为广泛的一类进程间通信的机制。消息传递系统分成两类：</p><ol><li><strong>直接通信</strong>方式：是指发送进程利用OS所提供的发送原语，直接把消息发送给目标进程；</li><li><strong>间接通信</strong>方式：是指发送和接收进程，都通过共享中间实体（称为邮箱）的方式进行消息的发送和接收，完成进程间的通信。</li></ol></li></ol><h2 id=线程>线程</h2><p>​ <strong>线程是独立调度的基本单位</strong>，一个进程中可以有多个线程，他们共享进程资源。减少程序并发执行所需付出的时空开销，使操作系统具有更好发的并发性。</p><p>​ 线程的实现方式：</p><ol><li><strong>内核</strong>支持线程KST</li><li><strong>用户级</strong>线程ULT</li><li>组合方式：组合方式下包括三种不同的模型，如下图所示：</li></ol><p><a data-fancybox=gallery href=/operating_system/6.jpg><img class=mx-auto alt=组合方式 src=/operating_system/6.jpg></a></p><h3 id=线程的优缺点>线程的优缺点</h3><h4 id=用户线程优缺点>用户线程优缺点：</h4><ol><li>优点：用户及线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统<strong>开销小，效率高</strong></li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，<strong>并发弱</strong>。多个线程不可再多和处理机上并行运行。</li></ol><h4 id=内核级线程优缺点>内核级线程优缺点</h4><ol><li>优点：当一个线程被阻塞后，别的线程还可以继续进行，<strong>并发强</strong>。多线程可在多核处理机上并发运行。</li><li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的<strong>开销大，效率低</strong>。</li></ol><h2 id=进程与程序的区别>进程与程序的区别</h2><ol><li>最本质的区别：<strong>进程是动态的，程序是静态的</strong></li><li>程序可以写在纸上或在某一个存储介质上长期保存，而<strong>进程具有生存期</strong>，创建后存在，撤销后消亡</li><li>一个程序可以对应多个进程，但一个进程只能对应一个程序。</li></ol><h2 id=进程和线程的主要区别>进程和线程的主要区别</h2><ol><li>调度：在传统操作的操作系统中，<strong>独立调度的基本单位是进程</strong>，而在引入线程的操作系统中，<strong>线程是调度和分派的基本单位</strong>。</li><li>并发性：在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，因而操作系统具有<strong>更好的并发性</strong>，能更有效地使用系统资源和提高系统吞吐量。</li><li>拥有自由：不论是传统的操作系统，还是设有线程的操作系统，进程都是拥有资源和分配的独立单位，<strong>进程拥有自己的资源</strong>。一般地说，<strong>线程不拥有系统资源</strong>，但它可以访问隶属进程的资源</li><li>系统开销：<strong>切换进程时操作系统所付出的开销远大于切换线程的开销</strong></li></ol><h1 id=cpu调度与上下文切换>CPU调度与上下文切换</h1><h2 id=调用的基本概念>调用的基本概念</h2><p>​ 调度的实质是一种<strong>资源分配</strong>，处理机调度是对处理机资源进行分配。按照一定策略动态把处理机分配给处于就绪列的某个进程执行</p><ol><li><strong>处理机调度的层次</strong>：<ol><li>高度调度（作业调度）：选符合条件的作业装入内存</li><li>中级调度（内存调度）</li><li>低级调度（进程调度）：从就绪进程中选一个占用处理机</li></ol></li><li><strong>处理机调度算法的目标</strong>：<ol><li>资源利用率</li><li>公平性</li><li>平衡性</li><li>策略强制执行</li></ol></li></ol><blockquote><p>作业生存期：</p><ul><li>提交状态</li><li>后备状态（收容）</li><li>运行状态</li><li>完成状态</li></ul></blockquote><h2 id=衡量调度算法的性能指标>衡量调度算法的性能指标</h2><ol><li><strong>CPU利用率</strong>：CPU 处于忙状态的时间与开机运行总时间的比值。</li><li><strong>系统吞吐量</strong>：表示单位时间内CPU完成作业的数量</li><li><strong>响应时间</strong>：指用户从提交请求到系统首次产生响应所用的时间</li><li><strong>等待时间</strong>：作业处于等待处理机状态之和</li><li><strong>周转时间</strong>：指作用从提交到完成所经历的时间。<ol><li>周转时间 = 作业完成时间 - 作业提交时间</li><li>平均周转时间 = （作业1的周转时间 + &mldr; + 作业n的周转时间）/ n</li><li>带权周转时间 = 作业周转时间 / 作业实际运行时间</li></ol></li></ol><p>一般情况下，应根据设计的总体目标，合理地选择以上指标，从而有利于确定优良的调度算法。</p><h2 id=进程调度的时机>进程调度的时机</h2><p><a data-fancybox=gallery href=/operating_system/4.png><img class=mx-auto alt=进程的基本状态 src=/operating_system/4.png></a></p><p><strong>进程调度的时机</strong>有以下两种情况：</p><ol><li>当前进程<strong>主动放弃</strong>处理机<ol><li>进程正常终止</li><li>进程运行中发生异常终止</li><li>进程请求阻塞，如I/O请求</li></ol></li><li>当前进程<strong>被动放弃</strong>处理机<ol><li>分配给进程的时间片用完</li><li>有更紧急的事要处理（如I/O中断）</li><li>有更高优先级的进程进入队列</li></ol></li></ol><p><strong>不能进行进程调度与切换的情况</strong>：</p><ul><li>在处理中断的过程中</li><li>在操作系统内核程序临界区中</li><li>在原语中</li></ul><blockquote><ol><li>临界资源：在一段时间内只允许一个进程访问的资源<ol><li>硬件资源：打印机，磁带机</li><li>软件资源：栈、变量、表格</li></ol></li><li>临界区：每个进程中访问临界资源的那段代码</li></ol></blockquote><h2 id=进程调度的任务与方式>进程调度的任务与方式</h2><h3 id=进程调度的任务>进程调度的任务</h3><ol><li>保存镜像：保存处理机的现场信息</li><li>调度算法：按某种算法选取进程</li><li>进程切换：把处理机分配给进程</li><li>处理机回收：从进程收回处理机</li></ol><h3 id=进程调度的方式>进程调度的方式</h3><ol><li>非抢占式：实现简单系统开销小，但是无法及时处理紧急任务适合于早起的批处理系统</li><li>抢占式：可以优先处理紧急任务，也可以以时间片轮流执行，适用于分时系统和实时系统</li></ol><h2 id=经典调度算法>经典调度算法</h2><h3 id=先来先服务调度算法fcfs>先来先服务调度算法（FCFS）</h3><ul><li>作业调度、进程调度</li><li>非抢占式</li></ul><p>根据就绪队列按进入的先后次序获取CPU</p><table><thead><tr><th style=text-align:center>作业</th><th style=text-align:center>进入系统数据</th><th style=text-align:center>执行时间</th><th style=text-align:center>开始时间</th><th style=text-align:center>完成时间</th><th style=text-align:center>周转时间</th><th style=text-align:center>带权周转时间</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>8.00</td><td style=text-align:center>2.00</td><td style=text-align:center>8.00</td><td style=text-align:center>10.00</td><td style=text-align:center>2.00</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>8.50</td><td style=text-align:center>0.50</td><td style=text-align:center>10.00</td><td style=text-align:center>10.50</td><td style=text-align:center>2.00</td><td style=text-align:center>4</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>9.00</td><td style=text-align:center>0.10</td><td style=text-align:center>10.50</td><td style=text-align:center>10.60</td><td style=text-align:center>1.60</td><td style=text-align:center>16</td></tr><tr><td style=text-align:center>4</td><td style=text-align:center>9.50</td><td style=text-align:center>0.20</td><td style=text-align:center>10.60</td><td style=text-align:center>10.80</td><td style=text-align:center>1.30</td><td style=text-align:center>6.5</td></tr></tbody></table><p>平均周转时间 $t=1.725$</p><p>平均带权周转时间 $w=6.875$</p><h3 id=短作业优先调度算法sjf>短作业优先调度算法（SJF）</h3><ul><li>作业调度、进程调度</li><li>非抢占式</li></ul><p>该算法根据下一次所需时间的长短，从就绪状态中选择运行时间最短的进程首先占有CPU。有利于提高设备利用率，但同意出现饿死现象。</p><table><thead><tr><th style=text-align:center>作业</th><th style=text-align:center>进入系统数据</th><th style=text-align:center>执行时间</th><th style=text-align:center>开始时间</th><th style=text-align:center>完成时间</th><th style=text-align:center>周转时间</th><th style=text-align:center>带权周转时间</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>8.00</td><td style=text-align:center>2.00</td><td style=text-align:center>8.00</td><td style=text-align:center>10.00</td><td style=text-align:center>2.00</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>8.50</td><td style=text-align:center>0.50</td><td style=text-align:center>10.30</td><td style=text-align:center>10.80</td><td style=text-align:center>2.30</td><td style=text-align:center>4.6</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>9.00</td><td style=text-align:center>0.10</td><td style=text-align:center>10.00</td><td style=text-align:center>10.10</td><td style=text-align:center>1.10</td><td style=text-align:center>11</td></tr><tr><td style=text-align:center>4</td><td style=text-align:center>9.50</td><td style=text-align:center>0.20</td><td style=text-align:center>10.10</td><td style=text-align:center>10.30</td><td style=text-align:center>0.80</td><td style=text-align:center>4</td></tr></tbody></table><p>平均周转时间 $t=1.55$</p><p>平均带权周转时间 $w=5.15$</p><p>饥饿：某些进程也可能会长时间等待，当等待时间给进程推进和响应带来明显影响</p><p>饿死：当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义</p><h3 id=高响应比优先调度算法hrrn>高响应比优先调度算法（HRRN）</h3><ul><li><p>作业调度</p></li><li><p>非抢占式</p></li></ul><blockquote><p>响应比 = （等待时间+要求服务时间）/ 要求服务时间</p></blockquote><table><thead><tr><th style=text-align:center>作业</th><th style=text-align:center>进入系统时间</th><th style=text-align:center>执行时间</th><th style=text-align:center>开始时间</th><th style=text-align:center>完成时间</th><th style=text-align:center>周转时间</th><th style=text-align:center>带权周转时间</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>8.00</td><td style=text-align:center>2.00</td><td style=text-align:center>8.00</td><td style=text-align:center>10.00</td><td style=text-align:center>2.00</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>8.50</td><td style=text-align:center>0.50</td><td style=text-align:center>10.10</td><td style=text-align:center>10.60</td><td style=text-align:center>2.10</td><td style=text-align:center>4.2</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>9.00</td><td style=text-align:center>0.10</td><td style=text-align:center>10.00</td><td style=text-align:center>10.10</td><td style=text-align:center>1.10</td><td style=text-align:center>11</td></tr><tr><td style=text-align:center>4</td><td style=text-align:center>9.50</td><td style=text-align:center>0.20</td><td style=text-align:center>10.60</td><td style=text-align:center>10.80</td><td style=text-align:center>1.30</td><td style=text-align:center>6.5</td></tr></tbody></table><ol><li>作业1响应比：$(0+2)/2=1$</li><li>作业2响应比：$(1.5+0.5)/0.5=4$<ol><li>作业2响应比：$(1.6+0.5)/0.5=4.2$</li></ol></li><li>作业3响应比：$(1+0.1)/0.1=11$</li><li>作业4响应比：$(0.5+0.2)/0.2=3.5$<ol><li>$(0.6+0.2)/0.2=4$</li></ol></li></ol><blockquote><p>前三种算法都是非抢占式，一般适用于早起的批处理系统</p></blockquote><h3 id=时间片轮转调度算法rr>时间片轮转调度算法（RR）</h3><ul><li>进程调度</li><li>抢占式</li></ul><p>按一定时间片轮番运行各进程，如果时间片式一个定值，则对各个进程机会均等，适用分时操作系统</p><ol><li>每次选择就绪队列中的第一个进程，但是只能运行一个时间片大小</li><li>时间片长短的选择参考因素：系统的响应时间、就绪队列中的进程数目、系统的处理能力。时间片太大，相当于FCFS；太小，处理机切换频繁，开销增大</li></ol><h3 id=优先级调度算法pas>优先级调度算法（PAS）</h3><ul><li>作业调度、进程调度</li><li>抢占/非抢占式</li></ul><p>优先级调度法是为每个进程确定一个优先级，并按其高低确定占有CPU的次序，从而消除饿死现象。</p><ol><li>根据更高优先级进程是否可以抢占正在执行的进程，分类为：<ol><li>抢占式优先级调度算法</li><li>非抢占式优先级调度算法</li></ol></li><li>根据进程的优先级是否可以改变，将进程的优先级分为：<ol><li>静态优先级</li><li>动态优先级</li></ol></li><li>优先级：<ul><li>系统 > 用户</li><li>交互型 > 非交互型</li><li>I/O型 > 计算型</li><li>短作业 > 长作业</li></ul></li></ol><h3 id=多级反馈队列调度算法mfq>多级反馈队列调度算法（MFQ）</h3><ul><li>进程调度</li><li>抢占式</li></ul><ol><li>调度机制<ol><li>设置多个就绪队列，并为每个队列赋予不同的优先级。（第一梯队优先级最高，其余队列优先级依次降低）</li><li>各个队列中进程执行时间片大小不同。（优先级越高的队列中进程运行的时间片越小）</li><li>除第 n 队列外，每个队列都采用 <a href=#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95FCFS>FCFS</a> 算法，第 n 队列中按 <a href=%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95RR>RR</a> 方式运行</li></ol></li><li>调度算法的优势<ol><li>终端型用户：短作业优先</li><li>短批处理作业用户：周转时间短</li><li>长批处理作业用户：经历前面队列的部分执行，不会出现 “饥饿”</li></ol></li></ol><h3 id=经典调度算法总结>经典调度算法总结</h3><table><thead><tr><th></th><th style=text-align:center>先来先服务FCFS</th><th style=text-align:center>短作业优先SJF</th><th style=text-align:center>高响应比优先HRRN</th><th style=text-align:center>时间片轮转RR</th><th style=text-align:center>优先级调度PAS</th><th>多级反馈队列MFQ</th></tr></thead><tbody><tr><td>能否是可抢占</td><td style=text-align:center>否</td><td style=text-align:center>否</td><td style=text-align:center>否</td><td style=text-align:center>是</td><td style=text-align:center>是/否</td><td>是</td></tr><tr><td>优点</td><td style=text-align:center>有利于以CPU繁忙型（长）作业，充分利用CPU资源</td><td style=text-align:center>平均等待/周转时间最少</td><td style=text-align:center>兼顾长短作业</td><td style=text-align:center>用于分时系统，能及时响应</td><td style=text-align:center>可灵活的调账对各种作业或进程的偏好程度</td><td>有较好的响应时间，可行性强</td></tr><tr><td>缺点</td><td style=text-align:center>不利于I/O繁忙型（短）作业，操作耗时，会饥饿</td><td style=text-align:center>长作业会饥饿。估计时间不准确，不能保障紧迫任务及时处理</td><td style=text-align:center>计算响应比的开销大</td><td style=text-align:center>时间片的影响，上下文切换浪费时间</td><td style=text-align:center>低优先级进程可能会产生饥饿</td><td>可能导致饥饿</td></tr><tr><td>适用于</td><td style=text-align:center>作业/进程调度</td><td style=text-align:center>作业/进程调度</td><td style=text-align:center>作业调度</td><td style=text-align:center>进程调度</td><td style=text-align:center>作业/进程调度</td><td>进程调度</td></tr></tbody></table><h2 id=上下文及其切换机制>上下文及其切换机制</h2><p>进程上下文：进程物理实体和支持进程运行的环境</p><p>上下文切换：进程在当前上下文中运行，当系统调度新进程占有处理机时，新老进程发生上下文切换一个进程的上下文可以分为三个部分：</p><table><thead><tr><th>用户级上下文</th><th>系统级上下文</th><th>寄存器上下文</th></tr></thead><tbody><tr><td>用户堆栈</td><td>进程标识信息</td><td>程序状态字寄存器</td></tr><tr><td>用户数据块</td><td>进程现场信息</td><td>指令寄存器栈指针</td></tr><tr><td>用户程序块</td><td>进程控制信息</td><td>控制寄存器</td></tr><tr><td>共享地址空间</td><td>系统内核级</td><td>通用寄存器</td></tr></tbody></table><p>上下文切换发生在操作系统调度一个新进程到处理器时，需要完成以下三件事</p><ol><li>保存现场信息：将当前处理器的寄存器上下文保存到当前进程的系统级上下文的现场信息中；</li><li>恢复现场信息：将新进程系统级上下文的现场信息作为新的寄存器上下文恢复到处理器的各个寄存器中；</li><li>转移：将控制转移到新进程执行。</li></ol><h1 id=同步与互斥>同步与互斥</h1><h2 id=互斥和同步>互斥和同步</h2><p>间接相互制约关系（互斥）：进程排他性访问共享资源。</p><blockquote><p>互斥问题是相互无逻辑关系的进程间竞争使用相同的资源所发生的制约关系</p></blockquote><p>直接相互制约关系（同步）：进程间的合作，比如管道通信。</p><blockquote><p>同步问题是存在逻辑关系的进程之间相互等待产生的制约关系</p></blockquote><h2 id=互斥实现方法>互斥实现方法</h2><h3 id=软件实现法>软件实现法</h3><h4 id=单标志法>单标志法</h4><p><a data-fancybox=gallery href=/operating_system/7.png><img class=mx-auto alt=单标志法 src=/operating_system/7.png></a></p><h4 id=双标记法先检查>双标记法先检查</h4><p><a data-fancybox=gallery href=/operating_system/8.png><img class=mx-auto alt=双标记法先检查 src=/operating_system/8.png></a></p><blockquote><p>布尔型数组flag[]</p><p>flag[i]为true，进程已进入临界区</p><p>flag[i]为false，进程未进入临界区</p></blockquote><h4 id=双标志法后检查>双标志法后检查</h4><p><a data-fancybox=gallery href=/operating_system/9.png><img class=mx-auto alt=双标志法后检查 src=/operating_system/9.png></a></p><blockquote><p>布尔型数组flag[]</p><p>flag[i]为true，进程已进入临界区</p><p>flag[i]为false，进程未进入临界区</p></blockquote><p>皮特森算法（Peterson&rsquo;s Algorithm）</p><p><a data-fancybox=gallery href=/operating_system/10.png><img class=mx-auto alt=皮特森算法 src=/operating_system/10.png></a></p><h4 id=硬件实现方法>硬件实现方法</h4><p>中断屏蔽法（关中断/开中断）：当一个进程正在使用处理机执行他的临界区代码时，防止其他进程进入其临界区进行访问的最简方法是。禁止一切中断发生，或称之为屏蔽中断、关中断。</p><p>TSL指令（Test-And-Set-Lock）：这条指令是原子操作，指执行该代码时不允许被中断。其功能是读出指定标记后把该标志为真。</p><p>Swap指令：这条指令是原子操作，交换两个变量的值。</p><p><a data-fancybox=gallery href=/operating_system/11.png><img class=mx-auto alt=硬件实现方法 src=/operating_system/11.png></a></p><blockquote><ol><li>软件实现方法：<ol><li>单标志法：违背 “空闲让进”</li><li>双标志法先检查：违背 “忙则等待”</li><li>双标志后检查：违背 “空闲让进”、“有限等待”</li><li>皮特森算法（Peterson‘s Algorithm）：违背 “让权等待”，会发生 “忙等”</li></ol></li><li>硬件实现方法：<ol><li>中断屏蔽法（关中断/开中断）：禁止一切中断发生</li><li>TLS指令（Test-And-Set-Lock）：原子操作，读取指定标志后把该标志设置为真</li><li>Swap指令：原子操作，交换两个变量的值</li></ol></li></ol></blockquote><h2 id=信号量semaphore机制>信号量（Semaphore）机制</h2><p>PV操作：</p><ul><li>P操作：wait原语，进程等待</li><li>V操作：signal原语，唤醒等待进程</li></ul><p><a data-fancybox=gallery href=/operating_system/12.png><img class=mx-auto alt=信号量机制 src=/operating_system/12.png></a></p><h2 id=经典同步问题>经典同步问题</h2><h3 id=生产者-消费者问题>生产者-消费者问题</h3><p><a data-fancybox=gallery href=/operating_system/14.png><img class=mx-auto alt=生产者-消费者问题 src=/operating_system/14.png></a></p><h3 id=读者-写者问题>读者-写者问题</h3><p><a data-fancybox=gallery href=/operating_system/15.png><img class=mx-auto alt=读者-写者问题 src=/operating_system/15.png></a></p><h3 id=哲学家进餐问题>哲学家进餐问题</h3><p><a data-fancybox=gallery href=/operating_system/16.png><img class=mx-auto alt=哲学家进餐问题 src=/operating_system/16.png></a></p><h1 id=死锁>死锁</h1><h2 id=死锁的基本概念>死锁的基本概念</h2><ol><li>死锁的定义：死锁是指多个进程因竞争资源而造成的一种相互等待，若无外力作用，这些进程都将无法继续运行。</li><li>产生死锁的原因：<ol><li>竞争不可抢占性资源</li><li>进程推进顺序不当</li></ol></li><li>产生死锁的必要条件：产生死锁必须同时具备下面四个必要条件，只要其中一个条件不成立，死锁就不会发生。<ol><li>互斥条件：共享资源的排他性访问</li><li>请求和保持条件：保持当前资源时请求另一个资源</li><li>不可抢占条件：存在共享资源的循环等待链</li></ol></li></ol><h2 id=死锁的处理方法>死锁的处理方法</h2><h3 id=预防死锁>预防死锁</h3><p>预防死锁的方法是通过破坏产生死锁的四个必要条件中的一个或几个，从而避免死锁的产生。</p><blockquote><p>互斥条件是非共享设备所必须得，不仅不能改变，还应加以保护。</p></blockquote><ol><li>破坏“请求和保持”条件<ol><li>方法：所有进程在开始运行之前，必须一次性地申请其在整个运行过程的所有资源。</li></ol></li><li>破坏“不可抢占”条件<ol><li>方法：当一个进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源。</li></ol></li><li>破坏“循环等待”条件<ol><li>方法：对系统所有资源类型进行线性排序，并赋予不同的序号。每个进程必须按序号递增的顺序请求资源。</li></ol></li></ol><h3 id=死锁避免>死锁避免</h3><p>在资源的动态分配中，用某种方法防止系统进入不安全状态，从而可以避免发生死锁。</p><p>常用的方法：</p><ol><li>系统安全状态<ol><li>安全状态是指系统能按某种进程顺序为每个进程P分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。此时称（P1，P2，&mldr;，Pn）为安全序列。</li><li>如果系统无法找到这样一个安全序列，则系统处于不安全状态。</li></ol></li><li>利用银行家算法避免死锁</li></ol><h3 id=死锁检测>死锁检测</h3><ol><li>资源分配图</li></ol><p><a data-fancybox=gallery href=/operating_system/13.png><img class=mx-auto alt=死锁检测 src=/operating_system/13.png></a></p><p>资源分配图中有环不一定存在死锁，无环一定没有死锁。</p><blockquote><p>资源分配图中的符号表示：</p><ol><li>圆圈代表一个进程。</li><li>方框代表一类资源。</li><li>方框中的一个点代表一类资源中的一个资源。</li><li>由进程出发到资源的有向边表示请求边。</li><li>由资源出发到进程的有向边表示分配边。</li></ol><p>环p1->r1->p2->r2->p3->r3->p1会发生死锁</p></blockquote><ol start=2><li>死锁定理：状态S为死锁状态的充分条件是当且仅当S状态的资源分配图不可完全简化。</li></ol><h3 id=死锁解锁>死锁解锁</h3><p>当检测到系统中已发生死锁时，就采用相当措施。将进程从死锁状态中解脱出来。常用的方法：</p><ol><li>资源剥夺法</li><li>终止进程法</li><li>进程回退法</li></ol></div><div class=post-archive><h2>See Also</h2><ul class=listing><li><a href=/operating_system/3/>内存管理与虚拟内存</a></li><li><a href=/operating_system/4/>文件系统</a></li><li><a href=/linux/epoll/>深入理解Linux中网络I/O复用并发模型</a></li><li><a href=/data_structure/data_stucture/>广东普通专升本计算机基础与程序设计2022考纲</a></li><li><a href=/data_structure/important/>概念及结论</a></li></ul></div><div class="post-meta meta-tags">没有标签</div></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo="your github repo" issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2023 <a href=https://sliverhorn.com>SliverHorn的博客 By SliverHorn</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>粤ICP备19128176号</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script src=/js/douban.js></script></div><div id=secondary><section class=widget><form id=search action=https://sliverhorn.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://sliverhorn.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://sliverhorn.com/post/aria2c/ title=Aria2c>Aria2c</a></li><li><a href=https://sliverhorn.com/post/linux/oh-my-zsh-install/ title="oh-my-zsh Mac 安装教程">oh-my-zsh Mac 安装教程</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list><li><a href=https://sliverhorn.com/categories/Linux/>Linux (1)</a></li><li><a href=https://sliverhorn.com/categories/Mac/>Mac (1)</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/tags/>标签</a></h3><div class=tagcloud><a href=https://sliverhorn.com/tags/oh-my-zsh/>oh-my-zsh</a>
<a href=https://sliverhorn.com/tags/tool/>tool</a></div></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://blog.leonardwang.cn/ title="牛逼哄哄 `王哥` 博客">牛逼哄哄 `王哥` 博客</a></li><li><a target=_blank href=https://www.cnblogs.com/binHome/ title=songzhibin97的博客>songzhibin97的博客</a></li><li><a target=_blank href=https://leixf.cn/ title="跃动指尖 – 悦动生活">跃动指尖 – 悦动生活</a></li><li><a target=_blank href=https://www.treesystem.cn title=术习电报>术习电报</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://sliverhorn.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>