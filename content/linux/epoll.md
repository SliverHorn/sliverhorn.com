---
title: "深入理解Linux中网络I/O复用并发模型"
date: 2022-11-05T17:17:17+17:17
draft: false
---

<!--more-->

## 基本概念

### 流

- 可以进行I/O操作的内核对象
- 文件、管道、套接字......
- 流的入口：文件描述符(fd)

### I/O操作

所有对流的读写操作，都可以称之为I/O操作

### 阻塞

- 阻塞等待：不占用CPU宝贵的时间片
  - 缺点：不能够很好的处理多个(I/O)请求的问题
  - 同一个阻塞，同一时刻只能处理一个流的阻塞监听
- 非阻塞忙轮询 ：占用CPU，系统资源

> 在处理意见数据的接收场景时，建议优先使用阻塞等待的方式，不浪费性能资源

### 多路IO复用

- 既能够阻塞等待，不浪费资源
- 也能够同一时刻监听多个IO请求的状态

## 解决阻塞死等待的缺点

1. 阻塞等待+多进程/多线程：需要开辟线程浪费资源
2. 非阻塞+忙轮询：
   1. CPU在大量的做判读，while 和 for
   2. CPU的利用率不高

```
while true {
	for i in 流[] {
		if i has 数据 {
			读 或者 其他处理
		}
	}
}
```

3. 多路IO复用机制 -- select
   1. 监听的IO数量有限，默认是1024个
   2. 不会精准的告诉开发者，哪些IO是可读可写的，需要遍历

```
while true {
	select(流[]); // 阻塞
	// 有消息抵达
	for i in 流[] {
		if i has 数据 {
			读 或者 其他处理
		}
	}
}
```

3. 多路IO复用机制 -- epoll
   1. 与 select，poll 一样，对I/O多路复用的技术
   2. 只关心“活跃”的链接，无需遍历全部描述集合
   3. 能够处理大量的链接请求(系统可以打开的文件数目， 可以通过/proc/sys/fd/file-max查看)

```
while true {
	可处理的流[] = epoll_wait(epoll_fd) // 阻塞
	
	// 有消息抵达,全部放在 “可处理的流[]”中
	for i in 可处理的流[] {
		读 或者 其他处理
	}
}
```

