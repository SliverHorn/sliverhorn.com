---
title: "第九章 并集查"
date: 2022-01-03T17:17:17+08:00
draft: false
---

<!--more-->

## 并集查的定义

在一些应用问题中，需将 $n$ 个不同的元素划分成一组不相交的集合。开始时，每个元素组成一个单元素集合，然后按一定顺序将属于同一组元素的集合合并。其间要反复用到查询某个元素属于哪个集合的运算。适合于描述这类问题的抽象数据类型称为并查集。它的数学模型是一组不相交的动态集合的集合 $S={A, B, C, ...}$ ，它支持以下运算。

- `UFunion(A, B, U)`：将并查集 $U$ 中的集合 $A$ 和 $B$ 合并，其结果取名为 $A$ 或 $B$。
- `UFfind(e)` : 找出包含元素 $e$ 的集合，并返回该集合的名字

## 用数组实现并查集

注意，在并查集中需要两种类型的参数：集合名字的类型和元素的类型。在许多情况下，可以用整数作为集合的名字。如果集合中共有 $n$ 个元素，可以用 `1~n` 范围内的整数来表示元素。实现并查集的一个简单方法是用数组来表示元素及其所属子集的关系。其中，用数组下标表示元素，用数组单元记录该元素所属的子集名字。若元素类型不是整型，则可以先构造一个映射，将每个元素映射成一个整数。这种映射可以用散列表或其他方式来实现。

### 具体代码实现

#### union_find_array.h

```c
// UnionFindArray 并查集指针结构
typedef struct unionFindArray *UnionFindArray;

// unionFindArray 并查集结构
typedef struct unionFindArray {
    int *Components; // 元素所属子集关系数组
    int Number; // 集合中元素个数
} unionFindArray;

#ifndef DATA_STRUCT_UNION_FIND_ARRAY_H
#define DATA_STRUCT_UNION_FIND_ARRAY_H

// UnionFindArrayInit 将 Components 初始化成大小为size 的单元素集合
UnionFindArray UnionFindArrayInit(int size);

// UnionFindArrayFind 找出包含元素 e 的集合
int UnionFindArrayFind(UnionFindArray u, int e);

// UnionFindArrayUnion 合并集合
int UnionFindArrayUnion(int i, int j, UnionFindArray u);

#endif //DATA_STRUCT_UNION_FIND_ARRAY_H

```

#### union_find_array.c

```c
#include <stdlib.h>

#include "union_find_array.h"

// UnionFindArrayInit 将 Components 初始化成大小为size 的单元素集合
UnionFindArray UnionFindArrayInit(int size) {
    UnionFindArray unionFindArray = (UnionFindArray) malloc(sizeof *unionFindArray);
    unionFindArray->Components = (int *) malloc((size + 1) * sizeof(int));
    for (int e = 0; e <= size; e++) {
        unionFindArray->Components[e] = e;
    }
    unionFindArray->Number = size;
    return unionFindArray;
}

// UnionFindArrayFind 找出包含元素 e 的集合
int UnionFindArrayFind(UnionFindArray u, int e) {
    return u->Components[e];
}

// UnionFindArrayUnion 合并集合
int UnionFindArrayUnion(int i, int j, UnionFindArray u) {
    for (int k = 1; k < u->Number;) {
        if (u->Components[k] == j) {
            u->Components[k] = i;
        }
    }
    return i;
}
```



