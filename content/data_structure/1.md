---
title: "第一章 绪论"
date: 2021-12-28T17:17:17+08:00
categories: ["DataStructure"]
draft: true
---

<!--more-->

## 数据结构的基本概念

|          | 概念                                                         |
| -------- | ------------------------------------------------------------ |
| 数据     | 信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合 |
| 数据元素 | 一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位 |
| 数据项   | 构成数据元素的不可分割的最小单位，一个数据元素可由若干个数据项组成 |
| 数据对象 | 具有相同性质的数据元素的集合，是数据的一个子集               |
| 数据类型 | 一个值的集合和定义在此集合上的一组操作的总称                 |
| 数据结构 | 相互之间存在一种或多种特定关系的元素的集合，包括：逻辑结构、存储结构和数据运算<br />数据结构的形式定义为:数据结构是一个二元组<br />Data Structure = (D,S)<br />其中: 是数据元素的有限集， 是 上关系的有限集。 |

## 数据结构三要素

### 逻辑结构

逻辑结构是指数据元素之间的逻辑关系，与数据的存储无关，独立于计算机。

- 线性结构 （一对一）
  - 线性表
    - 线性表
    - 栈
    - 队列
    - 串
    - 数组
- 非线性结构 （一对多 || 多对多）
  - 集合
  - 树形结构
  - 图形结构（网状结构）

### 存储结构

存储结构(物理结构)是指数据结构在计算机中的表示，它包括数据元素的表示和关系的表示。

- 顺序存储
  - 把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。
  - 优点是可以实现随机存取，每个元素占用最少的存储空间；
  - 缺点是只能使用相邻的一块存储单元，因此可能产生较多的外部碎片。
- 链式存储
  - 借助指示元素存储地址的指针来表示元素之间的逻辑关系。
  - 优点是不会出现碎片现象，能充分利用所有存储单元；
  - 缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。
- 索引存储
  - 在存储元素信息的同时，还建立附加的索引表。
  - 优点是检索速度快；
  - 缺点是增加附加的索引表后会占用较多的存储空间。另外，在增加和删除数据时要修改索引表，因而会花费较多的时间。
- 散列存储
  - 根据元素的关键字直接计算出该元素的存储地址，又称哈希( )存储
  - 优点是检索、增加和删除结点的操作都很快；
  - 缺点是若散列函数不好，则可能出现元素存储单元冲突，而解决冲突会增加时间和空间开销。

### 数据运算

定义是针对逻辑结构的，指出运算的功能；实现是针对存储结构的，指出运算的具体操作步骤

## 算法

算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。此外，一个算法还具有下列 个重要特性:

- 有穷性。一个算法必须总是在执行有穷步后结束，且每一步都是在有穷时间内完成。
- 确定性。算法中每条指令必须有确切的含义，且相同的输入只能得到相同的输出。 
- 可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
- 输入。一个算法有零个或多个输入。
- 输出。一个算法有一个或多个输出。

通常设计一个“好”的算法应考虑达到以下目标: 

- (1)正确性。算法应能够正确地求解问题。
- (2)可读性。算法能具有良好的可读性，以帮助人们理解。
- (3)健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。
- (4)效率与低存储量需求。效率是指算法执行的时间，存储量需求是指算法执行过程中所需的最大存储空间。

算法效率的度量是通过时间复杂度和空间复杂度来描述的。 一个语句的频度是指该语句在算法中被重复执行的次数。 算法中所有语句的频度之和记为 ，它是该算法问题规模 的函数，时间复杂度主要分 析 的数量级。

### 加法规则

$$
T(n) = T_1(n) + T_2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n)))
$$

## 乘法规则

$$
T(n) = T_1(n) \times T_2(n) = O(f(n)) \times O(g(n)) = O(f(n) \times g(n)))
$$

### 常见的渐近时间复杂度

$$
O(1) \lt O(log_2{n}) \lt O(n) \lt O(nlog_2{2}) \lt O(n^2) \lt O(n^3) \lt O(2^n) \lt O(n!) \lt O(n^n)
$$

