---
title: "第五章 排序与选择算法"
date: 2021-12-30T17:17:17+08:00
draft: false
---

<!--more-->

![十大排序算法](https://camo.githubusercontent.com/64f6d0498e1ebdc96f6aa8721eb17c96d13fc142b833df68dbbecc0fcc9ceef0/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d376361663761386465633039356138302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

按照某个线性序（如数的小于关系）对一些对象进行排序是用计算机处理信息时经常要做的一项基本工作，有必要对它进行详细的讨论。在一般情况下，排序问题的输入是 $n$ 个数 $a[0], a[1],...,a[n-1]$ 的一个序列，要设计一个有效的排序算法，产生输入序列的一个重排，使序列元素按从小到大的顺序排列。输入序列通常是一个有n 个元素的数组，当然也可以用其他形式来表示输入，如链表等。在实际应用中，待排序的对象往往不是单一的数而是一个记录，其中有一个关键字域key，它是排序的根据。在key 的数据类型上定义了某个线性序。例如，整数、实数和字符串等都可以作为键。记录的其他数据称为卫星数据，即它们都是以 key 为中心的。在一个实际的排序算法中对关键字重排时，卫星数据也要随关键字一起移动。如果每个记录都很大，就可以对一组指向各个记录的指针进行排序，以减少数据移动量。对于排序算法来说，不论待排序对象是单个数值还是记录，它们的排序方法都一样。在排序时，待排序记录的键值可,能有相同的，对于键值相同的记录，通常并不要求它们之间进行排列，只要求在最后输出时，键值小者排在键值大者之前。

对排序算法计算时间的分析可以遵循若干种不同的准则，通常以排序过程中所需要的算法步数作为度量，有时也以排序过程中所进行的键值比较次数作为度量。特别是当一次键值比较需要较长时间，如当键是较长的字符串时，常以键值比较次数作为排序算法计算时间复杂性的度量。当排序算法需要移动记录，且记录都很大时，还应该考虑记录的移动次数。

> 以下介绍的 3 个算法对待排序数组元素 $a[0], a[2],..., a[n-1]$ 排序都需要 $O(n^2)$ 计算时间，并且对每个算法都存在某个由 $n$ 个元素组成的输入序列，使它们确实需要 $\Omega(n^2)$ 计算时间。

## 冒泡排序

![冒泡排序算法](https://camo.githubusercontent.com/2ccb6aeadb6f7ab539455635324280e58e858199a251888ad74bce6810a571b8/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d666166636634393939376435313165652e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970)

最简单的排序算法是冒泡排序算法。这种算法的基本思想是，将待排序的记录看成竖着排列的 “气泡”，键值较小的记录比较轻，因而要往上浮。在冒泡排序算法中，要对这个“气泡”序列处理若干遍。所谓处理一遍，就是自底向上检查一遍这个序列，并时刻注意两个相邻的记录的顺序是否正确。如果发现两个相邻记录的顺序不对，即“轻”的记录在下面，就变换它们的位置。显然，处理一遍之后，“最轻”的记录就浮到了最高位置：处理两遍之后，“次轻”的
记录就浮到了次高位置。在进行第二遍处理时，由于最高位置上的记录己是“最轻”记录，所以不必检查。一般地，第 $i$ 遍处理时，不必检查第 $i$ 高位置以上的记录。设待排序的数组段是 `a[l]~a[r]` ，则冒泡排序算法可实现如下。

```c
// element 待排序元素类型
typedef int element;

// Element 待排序元素指针类型
typedef element *Element;

void SortBubble(element a[], int l, int r) {
    for (int i = l; i <= r; i++ ) {
        for (int j = i; j < l; j--) {
            compswap(a[j-1], a[j]);
        }
    }
}
```

上述冒泡排序算法中，待排序元素类型是 `element`，算法根据 Item 类型元素的键值对数组元素 `a[l]~a[r]` 进行排序。算法中用到的关于 `element` 类型变量的一些常用运算，如交换两个元素 A 和 B 值的运算 `swap(A,B)` 等，许多排序算法中都会用到，定义如下。

```c
#define key(A) (A)
// less(A,B) 比较 A 和 B 的键值，等价于 key(A) < key(B)
#define less(A,B) (key(A) < key(B))
// eq(A,B) 等价于 `key(A) == key(B)`
#define eq(A,B) (!less(A,B) && !less(B,A))
// swap(A,B) 交换两个元素 A 和 B 的值；
#define swap(A,B) {element t = A; A = B; B = t;}
// compswap(A,B) 等价于语句 `if (less(B,A)) swap(A,B)` ，即当 `key(B) < key(A)` 时，交换 A 和 B 的值。
#define compswap(A,B) if (less(B,A)) swap(A,B)
```

> 时间复杂度

由于 `compswap` 运算需要 $O(1)$ 计算时间，所以冒泡排序算法的
循环体耗时 $O(1)$ 。由此可知整个算法所需的时间为
$$
\sum_{i=2}^n\sum_{j=0}^{i-2}O(1) =O(\sum_{i=1}^{n-1}\sum_{j=1}^{i}1) = O(n^2)
$$
最坏情况在输入元素序列完全逆序排列时发生。另一方面，即使不需要交换位置，即输入的元素序列己经排好序，算法仍需执行 $n(n-1)/2$ 次元素比较，因此算法至少需要 $\Omega(n^2)$ 计算时间。

## 插入排序

![插入排序](https://camo.githubusercontent.com/0a9709002864a76aa5430f7ab33365200a2cdc4904761f9a13452792c537c498/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d393435356666313362633866626463362e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970)

插入排序算法的基本思想是，对数组元素 `a[l]~a[l]` ，经过前 `i-l` 遍处理后，$a[l], a[l+1],...,a[i-l]$ 己排好序。下一遍处理就是要将 $a[i]$ 插入 $a[l], a[l+1],...,a[i-l]$ 的适当位置，使得 $a[l], a[l+1],...a[i]$ 是排好序的序列。要达到这个目的，可以用顺序比较的方法，首先比较 $a[i]$ 和 $a[i-1]$ ，若 $a[i-1] \leq a[i]$ ，则 $a[l], a[l+1],...a[i]$ 已排好序，第 $i$ 遍处理就结束了；否则交换 $a[i-1]$ 与 $a][1]$ 的位 置，继续比较 $a[i-1]$ 和      $a[i-2]$，直到找到某一个位置 $j(1 \leq j \leq i-1)$，使得当 $a[j] \leq a[j+1]$ 时为止。上述元素插入过程由算法             `insert` 来完成。

```c
#include "sort_select.h"

// insert 元素 a[i] 插入 数组 a[l:i]
void insert(element a[], int l, int i) {
    element v = a[i];
    while (i > l && less(v, a[i-1])) {
        a[i] = a[i-1]; i--;
    }
}
```

插入入排序算法通过反复调用 `insert` 来完成排序任务。

```c
#include "sort_select.h"

// SortInsert 插入排序算法
void SortInsert(element a[], int l, int r) {
    for (int i = l + 1; i <= r; i++) {
        insert(a, l, i);
    }
}
```

> 时间复杂度

插入排序算法对固定的 $i$ ， $insert(a, 0, i)$ 在最坏情况下需要 $O(i)$ 计算时间。因此整个插入排序算法所需的时间为
$$
\sum_{i=1}^{n-1}O(i) =O(\sum_{i=1}^{n-1}i) = O(n^2)
$$
最坏情况在输入元素序列完全逆序排列时发生。此时对任意的 $i$ ，算法 `insert` 需要进行 $i$ 次比较和交换。因此在整个插入排序算法中执行的比我利交换次数为 $\sum_{i=1}^{n-1}i=n(n-1)/2$ 。由此可知，在最坏情况下，插入排序算法需要 $\Omega(n^2)$ 计算时间。

## 希尔排序

![希尔排序](https://camo.githubusercontent.com/68a3945dc668bee934f15515e942a2e5c2a6b3871933359cda5432b5cd42820d/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d616363366336663136623039363739342e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970)

- 选择一个增量序列 $t_1, t_2 ,..., t_k$，其中 $t_i > t_j$ , $t_k = 1$；
- 按增量序列个数 k，对序列进行 $k$ 趟排序；
- 每趟排序，根据对应的增量 $t_i$，将待排序列分割成若干长度为 $m$ 的子序列，分别对各子表进行直接插入排序。仅增量因子为 $1$ 时，整个序列作为一个表来处理，表长度即为整个序列的长度

> 空间效率: 仅使用了常数个辅助单元，因而空间复杂度为 。

> 时间效率: 由于希尔排序的时间复杂度依赖于增量序列的函数，所以其时间复杂度分析比较困难。

> 稳定性:不稳定。

## 选择排序

![选择排序](https://camo.githubusercontent.com/0a9709002864a76aa5430f7ab33365200a2cdc4904761f9a13452792c537c498/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d393435356666313362633866626463362e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970)

选择排序算法的基本思想是对待排序的元素序列 `a[l] ~ a[r]` 进行 $r-l$ 遍处理，第 $i$ 遍处理是将 $a[l+i-1], a[l+i],...,a[r]$ 中最小者与 a[l+i-1] 交换位置。这样，经过 $i$ 遍处理之后，较小的 $i$ 个元
素的位置己经是正确的了。确定 $a[i:r]$ 中最小元素下标的算法 `mini` 可表述如下。

```c
// mini 确认 a[i:r] 中的最小元素下标
int mini(element a[], int i, int r) {
    int min = i;
    for (int j = i + 1; j <= r; j++) {
        if (less(a[j], a[min])) {
            min = j;
        }
    }
    return min;
}


```

利用函数 `mini` ，选择排序算法可实现如下。

```c
// SortSelect 选择排序算法
void SortSelect(element a[], int l, int r) {
    for (int i = l; i < r; i++) {
        int j = mini(a, i, r);
        swap(a[i], a[j]);
    }
}
```

> 时间复杂度

选择排序算法的第 $i$ 遍处理是将 $a[i-1], a[i],...,a[n-1]$ 中最小者与 $a[i-1]$ 交换位置。而确定 $a[i-1:n-1]$ 中最小元素下标的算法 `mini` 需要 $O(n-i)$ 计算时间。因此整个算法需要的计算时间为
$$
\sum_{i=1}^{n-1}O(n-i) =O(\sum_{i=1}^{n-1}(n-i)) = O(n^2)
$$
另一方面，对于任何输入序列，选择排序算法总要执行 $n(n-1)/2$ 次元素比较，因此选择排
序算法至少需要 $\Omega(n^2)$ 计算时间。

## 快速排序

![快速排序](https://camo.githubusercontent.com/eddb0d91c28d3a312ebbb9df0af5620176f191d5094e54925f8f9b7de14d0048/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d366430316661663037613231653733302e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970)

事实上，在判定树计算模型下，任何一个基于比较的排序算法都需要 $O(nlogn)$ 计算时间。若能设计一个
需要 $O(nlogn)$ 时间的排序算法，则在渐近的意义上，这个排序算法是最优的。

快速排序算法是基于分治策略的排序算法。其基本思想是，对于输入的子数组 $a[l:r]$，按以下3个步骤进行排序。

- (1) 分解：以 $a[r]$ 为基准元素将 $a[l:r]$ 划分成3段 $a[l:i-1]$ ， $a[i]$ 和 $a[i+1:r]$ ，使得 $a[l:i-1]$ 中任何一个元素小于等于 $a[i]$ ，$a[i+1:r]$ 中任何一个元素大于等于 $a[i]$ 。下标 $i$ 在划分过程中确定。
- (2) 递归求解：通过递归调用快速排序算法分别对 a[l:i-1] 和 a[i+1:r] 进行排序。
- (3) 合并：由于对 $a[l:i-1]$ 和 a[i+1:r] 的排序是就地进行的，所以在 $a[l:i-1]$ 和 $a[i+1:r]$ 都己排好序后不需要执行任何计算， $a[l:r]$ 就己排好序。

基于这个思想，可实现快速排序算法如下。

```c
#include "sort_quick.h"

// SortQuick 快速排序算法
void SortQuick(element a[], int l, int r) {
    if (r <= l) {
        return;
    }
    int i = partition(a, l, r);
    SortQuick(a, l, i - 1); // 对左半段排序
    SortQuick(a, i + 1, r); // 对右半段排序
}
```

对含有 $n$ 个元素的数组 $a[0:n-1]$ 进行快速排序只要调用 `SortQuick(a, 0, n-1)` 即可。
上述算法中的函数 `partition` ，以一个确定的基准元素 $a[r]$ 对子数组 $a[l:r]$ 进行划分，它是快速排序算法的关键。

```c
#include "sort_quick.h"

// partition 元素划分算法
int partition(element a[], int l, int r) {
    int i = l - 1, j = r;
    element v = a[r];
    for (;;) {
        while (less(a[++i], v));
        while (less(v, a[--j])) {
            if (j == l) {
                break;
            }
        }
        if (i >= j) {
            break;
        }
        swap(a[i], a[j]);
    }
    swap(a[i], a[r]);
    return i;
}
```

函数 `partition` 对叫进行划分时，以元素 `v = a[r]` 作为划分的基准，分别从左、右两端开始，扩展两区域  $a[l:r]$ 和 $a[j:r]$ ，使得 $a[l:r]$ 中元素小于或等于 `v` ，而 $a[j:r]$ 中元素大于或等于 `v` 。初始时，`i = l - 1` 且 `j = r` 。

在第7~10行的for 循环体中，下标 $j$ 逐渐减小， $i$ 逐渐增大，直到 $a[i] \ge v \ge a[j]$。若这两个不等式是严格的，则 $a[i]$ 不会是左边区域的元素，而 $a[j]$ 不会是右边区域的元素。此时若 $i \lt j$ ，则交换 $a[i]$ 与 $a[j]$ 的位置，扩展左右两个区域。

for 循环重复至的 $i \ge j$ 时结束。这时 $a[l:r]$ 己被划分成 $a[l:i-1]$ ，$a[i]$ 和 $a[i+1:r]$ ，且满足 a[l:i-1] 中元素不大于 $a[i+1:r]$ 中元素。在两数 `partition` 结束时返回划分点 $i$ 。

事实上，函数 `partitio` 的主要功能就是将小于 `v` 的元素放在原数组的左半部分；而将大于 `v`  ，的元素放在原数组的右半部分。其中，有一些细节需要注意。例如，算法中的下标 $i$ 和 $j$ ；不会超出 $a[l:r]$ 的下标界。另外，在快速排序算法中选取 $a[r]$ 作为基准可以保证算法正常结束。

> 时间复杂度

对于输入序列 a[l:r]，函数 `partition` 的计算时间显然为 O(r-l-1) 。
对含有 n 个元素的数组 a[0:n-1] 进行快速排序的运行时间与划分是否对称有关，其最坏情况发生在划分过程中产生的两个区域分别包含  $n-1$ 个元素和 $1$ 个元素的时候。由于函数 `partition` 的计算时间为 $O(n)$ ，所以若两数 `partition` 的每一步都出现这种不对称划分，则其时间复杂性 $T(n)$ 满足
$$
T(n) = 
\begin{cases}
O(1), & n \leq 1\\
T(n-1)+O(n), & n \gt 1
\end{cases}
$$
解此递归方程可得 $T(n) = O(n^2)$

在最好情况下，每次划分所取的基准都恰好为中值，即每次划分都产生两个大小为 $n/2$ 的区域，此时，两数`partition` 的计算时间 $T(n)$ 满足
$$
T(n) = 
\begin{cases}
O(1), & n \leq 1\\
2T(n/2)+O(n), & n \gt 1
\end{cases}
$$
其解为 $T(n) = O(nlogn)$ 。
可以证明，快速排序算法在平均情况下的时间复杂性也是 $O(nlogn)$ ，这在基于比较的排序算法类中算是快速的了，快速排序算法也因此而得名。

## 合并排序

![合并排序](https://camo.githubusercontent.com/f1271f5697f6d1c3d4b37ee800c5324222bc858549cafa1b4d42cbb68c5f3e7f/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d643364343030363836626336316333302e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970)

合并排序算法是用分治策略实现对 $n$ 个元素排序的算法。其基本思想是：当 $n = 1$ 时终止排序，否则将待排序元素分成大小大致相同的两个子集，分别对两个子集进行排序，最终将排好序的子集合并为所求的排好序的集合。

合并排序算法可递归地描述如下。

```c
#include "sort_merge.h"

// mergeAB 合并 a[l:m] 和 a[m+1:r] 到 b[l:r]
void mergeAB(element a[], element b[], int l, int m, int r) {
    int i = l, j = m + 1, k = 1;
    while ((i <= m) && (j <= r)) { // 取两段中较小元素到数组b中
        if (less(a[i], a[j])) {
            b[k++] = a[i++];
        } else {
            b[k++] = a[j++];
        }
    }
  	// 处理剩余元素
    if (i > m) {
        for (i = j; i < r; i++) {
            b[k++] = a[i];
        }
    } else {
        for (; i < m; i++) {
            b[k++] = a[i];
        }
    }
}
```

其中，在第7行由算法 `mergeAB` 把两个排好序的数组段合并到一个新的数组 $b$ 中，然后在第8行由函数 `copy` 将合并后的数组段复制回数组 $a$ 中。

```c
#include "sort_merge.h"

// copy
void copy(element b[], element a[], int l, int r) {
    for (int i = l; i <= r; i++) {
        a[i] = b[i];
    }
}

// SortMerge 合并排序算法
void SortMerge(element a[], int l, int r) {
    int m = (r + l) / 2; // 取中点
    if (r <= l) {
        return;
    }
    element b[] = {};
    SortMerge(a, l, m); // 对左半段排序
    SortMerge(a, m + 1, r); // 对右半段排序
    mergeAB(a, b, l, m, r); // 合并到数组b
    copy(b, a, l, r); // 复制回数组a
}
```

`mergeAB` 和 `copy` 显然可在 $O(n)$ 时间内完成，因此合并排序算法对八个元素进行排序，在最坏情况下所需的计算时间 $T(n)$ 满足
$$
T(n) =
\begin{cases}
O(1), & n \leq 1  \\
2T(\frac{n}{2})+O(n), & n \gt 1
\end{cases}
$$


解此递归方程可知 $T(n)=O(nlogn)$ 。由于排序问题的计算时间下界为 $\Omega(nlogn)$，所以合并排序算法是一个渐近最优算法。

## 堆排序

![堆排序](https://camo.githubusercontent.com/374302b5edfc5aa8f7f811437d966841f29bcd67643a918542ef3e7a4bfe275a/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d303437613930376431363261346130622e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970)



## 计数排序

![计数排序](https://camo.githubusercontent.com/bdead06c3a5b84b73fe4bbc6472cd4a563709b4b849ceff08c7fd4f29cb7dfb5/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d656131316135326465646166303739352e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970)

计数排序算法的基本思想是：对每一个输入元素 $x$ ，确定输入序列中键值小于 $x$ 的元素个数。一旦有了这个信息，就可以将 $x$ 直接存放到最终的输出序列的正确位置上。

为便于讨论，在下面的计数排序算法中，假设输入的 $n$ 个元素存放在数组 $a[0:n-1]$ 中；输出的排序结果存放在数组 $b[0:n-1]$ 中。数组 a 和 b 中的每个元素均为 `0~m` 之间的一个整数。算法中还用到一个辅助数组 $cnt[0:m]$ 用于对输入元素进行计数。

计数排序算法描述如下。

```c
#include <stdlib.h>

#include "sort_count.h"

#define m 10

// SortCount 计数排序算法
void SortCount(element a[], int l, int r) {
    element *b = (element *) malloc(sizeof(element) * (r + 1));
    int cnt[m] = {0};
    for (int i = l; i <= r; i++) {
        cnt[a[i]]++;
    }

    for (int i = 1; i < m; i++) { // cnt[i] 中存放的是 a[l, r] 中键值等于 i 的元素个数
        cnt[i] += cnt[i - 1];
    }

    for (int i = r; i >= l; i--) { // cnt[i] 中存放的是 a[l, r] 中键值小于或等于 i 的元素个数
        b[--cnt[a[i]]] = a[i];
    }
    for (int i = l; i <= r; i++) {
        a[i] = b[i - 1];
    }
    free(b);
}
```

> 时间复杂度

对数组 `cnt` 初始化需要 $O(m)$ 时间。顺序检查每个输入元素需要 $O(n)$ 时间。对每个 $i = 1, 2,..., m$ ，统计值小于或等手i的输入元素个数需要 $O(m)$ 时间。最后，将每个元素输出到数组 $b$ 中需要 $O(n)$ 时间。这样，整个算法所需的计算时间为 $O(m+n)$。当 $m = O(n)$ 时，算法的计算时间复杂性为 $O(n)$。

计数排序算法没有比较元素大小，它利用元素的值来确定其正确的输出位置。因此，计数排序算法不是一个基于比较的排序算法，从而它的计算时间下界不再是 $\Omega(nlogn)$。另一方面，计数排序算法之所以能取得线性计算时间上界，是因为对元素的取值范围作了一定限制，即 $m = O(n)$ 。如果 $m = n^2, n^3,...$ 就得不到线性时间上界。

计数排序算法的另一个重要性质是，在输入和输出序列中，具有相同值元素的相对次序不变。计数排序算法是一个稳定的排序算法。

## 桶排序

![桶排序](https://camo.githubusercontent.com/0976a87ffacde6a53f8fa3001740774ca092139e1cd33807d55199386b09a7bc/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d613161373563666366633064356662642e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970)

桶排序算法的基本思想是：设置若干个桶，将键值等于 $i$ 的元素全部装入第 $i$ 个桶中：然后，按桶的顺序将桶中元素顺序连接起来。

由于每个桶中元素键值相同，可以将第 $i$ 个桶看成键值为 $i$ 的元素组成的一个表。用数组`bottom` 表示桶底，`bottom[i]` 指向第i个桶中第一个元素。用数组 `top` 表示桶顶，`top[i]` 指向第 $i$ 个桶中最后一个元素。这样很容易按桶的顺序将桶中元素顺序连接在一起。

下面给出桶排序算法。该算法假定输入序列以单链表形式给出，桶排序算法返回排序后的单链表。元素键值上界为 $m$ 。

```c
#include "sort_bucket.h"
#include "../table/table_single_chain.h"

// SortBucket 桶排序算法
TableSingleNode SortBucket(TableSingleNode node) {
    int b = 0; // 桶下标
    TableSingleNode bottom[m + 1], top[m + 1];
    TableSingleNode p = 0;
    for (b = 0; b <= m; b++) { // 桶初始化
        bottom[b] = 0;
    }
    for (; node; node = node->Next) { // 将元素装入桶中
        b = node->Element;
        if (bottom[b]) { // 桶非空
            top[b]->Next = node;
            top[b] = node;
        } else { // 桶空
            bottom[b] = top[b] = node;
        }
    }

    for (b = 0; b <= m; b++) {
        if (bottom[b]) { // 桶非空
            if (p) { // 不是第一个非空桶
                p->Next = bottom[b];
            } else { // 第一个非空桶
                node = bottom[b];
            }
            p = top[b];
        }
    }
    if (p) {
        p->Next = 0;
    }
    return node;
}
```

桶排序算法所需的计算时间与计数排序算法所需的计算时间大致相同，它们都需要 $O(m+n)$ 计算时间。初始化空桶需要 $O(m)$ 时间。将所有输入元素装入桶中共需 $O(n)$ 时间。将桶中元素依序连接共需 $O(m)$ 时间。于是，整个桶排序算法共用 $O(m+n)$ 时间。与计数排序算法类似，若 $m = O(n)$ ，则桶排序算法只需要 $O(n)$ 计算时间。

## 基数排序

![基数排序](https://camo.githubusercontent.com/fee89acc9fcce338264c446a83d6ae5964f05405dd55fc27a8ef970251a8491b/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d663739353332343435366535373137642e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970)

基数排序算法是一个与计数排序和桶排序算法十分类似的线性时间排序算法。其基本思想是将输入数据看成具有相同长度的正整数，长度较短的数在高位用 $0$ 补齐；然后，从最低位开始，按照从低位到高位的次序，依次对上一轮排序后数据的高一位数值做一次排序，直至最高位后完成排序

```c
#include <stdlib.h>

#include "sort_radix.h"

#define RADIX 7

// SortRadix 一般基数排序算法
void SortRadixGeneral(element a[], int l, int r) {
    int max = 0, pow = 1;
    int *b = (element *) malloc(sizeof(element) * (r + 1));
    for (int i = l; i <= r; i++) {
        if (a[i] > max) { // max 是 a[l, r]中的最大整数, 用于确定 while 循环的次数
            max = a[i];
        }
    }
    while (max / pow > 0) {
        int cnt[RADIX] = {0}; // 清空计数器
        for (int i = l; i <= r; i++) { // 按位计数
            cnt[a[i] / pow % RADIX]++; // cnt[i] 中存放的是 a[l,r] 中键值 p 位等于 i 的元素个数
        }
        for (int i = 1; i < RADIX; i++) { // 前缀和
            cnt[i] += cnt[i - 1]; // cnt[i] 中存放的是 a[l, r] 中键值 p 位 小于或者等于 i 的元素个数
        }
        for (int i = r; i >= l; i--) { // 按位排序
            b[--cnt[a[i] / pow % RADIX]] = a[i];
        }
        for (int i = r; i <= r; i++) {
            a[i] = b[i - l]; // 回写a
        }
        pow *= RADIX;  // 进位
    }
    free(b);
}

// SortCount 按位计数排序
void SortCount(element a[], element b[], int l, int r, int p) {
    int cnt[RADIX] = {0}; // 清空计数器
    for (int i = l; i <= r; i++) { // 按位计数
        cnt[a[i] / p % RADIX]++; // cnt[i] 中存放的是 a[l,r] 中键值 p 位等于 i 的元素个数
    }
    for (int i = 1; i < RADIX; i++) { // 前缀和
        cnt[i] += cnt[i - 1]; // cnt[i] 中存放的是 a[l, r] 中键值 p 位 小于或者等于 i 的元素个数
    }
    for (int i = r; i >= l; i--) { // 按位排序
        b[--cnt[a[i] / p % RADIX]] = a[i];
    }
    for (int i = r; i <= r; i++) {
        a[i] = b[i - l]; // 回写a
    }
}

// SortRadix 基数排序算法
void SortRadix(element a[], int l, int r) {
    int max = 0, pow = 1;
    int *b = (element *) malloc(sizeof(element) * (r + 1));
    for (int i = l; i <= r; i++) {
        if (a[i] > max) { // max 是 a[l, r]中的最大整数, 用于确定 while 循环的次数
            max = a[i];
        }
    }
    while (max / pow > 0) {
        SortCount(a, b, l, r, pow); // 按位计数排序
        pow *= RADIX; // 进位
    }
    free(b);
}
```

对于输入数据 $a[0:n-1]$ ，按位计数排序算法 `SortCount` 所需计算时间是 $O(n)$。若输入数据的最高位是 $w$ ，则基数排序算法 `RadixSort` 所需计算时间显然是 $O(wn)$ 。在一般情况下 $w$ 是一个常数，从而基数排序算法 `SortRadix` 是一个线性时问算法。由计数排序算法的稳定性可知，基数排序算法 `SortRadix` 是稳定排序算法。

