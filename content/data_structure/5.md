---
title: "第五章 排序与选择算法"
date: 2021-12-30T17:17:17+08:00
draft: false
---

<!--more-->

![十大排序算法](https://camo.githubusercontent.com/64f6d0498e1ebdc96f6aa8721eb17c96d13fc142b833df68dbbecc0fcc9ceef0/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d376361663761386465633039356138302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

按照某个线性序（如数的小于关系）对一些对象进行排序是用计算机处理信息时经常要做的一项基本工作，有必要对它进行详细的讨论。在一般情况下，排序问题的输入是 $n$ 个数 $a[0], a[1],...,a[n-1]$ 的一个序列，要设计一个有效的排序算法，产生输入序列的一个重排，使序列元素按从小到大的顺序排列。输入序列通常是一个有n 个元素的数组，当然也可以用其他形式来表示输入，如链表等。在实际应用中，待排序的对象往往不是单一的数而是一个记录，其中有一个关键字域key，它是排序的根据。在key 的数据类型上定义了某个线性序。例如，整数、实数和字符串等都可以作为键。记录的其他数据称为卫星数据，即它们都是以 key 为中心的。在一个实际的排序算法中对关键字重排时，卫星数据也要随关键字一起移动。如果每个记录都很大，就可以对一组指向各个记录的指针进行排序，以减少数据移动量。对于排序算法来说，不论待排序对象是单个数值还是记录，它们的排序方法都一样。在排序时，待排序记录的键值可,能有相同的，对于键值相同的记录，通常并不要求它们之间进行排列，只要求在最后输出时，键值小者排在键值大者之前。

对排序算法计算时间的分析可以遵循若干种不同的准则，通常以排序过程中所需要的算法步数作为度量，有时也以排序过程中所进行的键值比较次数作为度量。特别是当一次键值比较需要较长时间，如当键是较长的字符串时，常以键值比较次数作为排序算法计算时间复杂性的度量。当排序算法需要移动记录，且记录都很大时，还应该考虑记录的移动次数。

> 以下介绍的 3 个算法对待排序数组元素 $a[0], a[2],..., a[n-1]$ 排序都需要 $O(n^2)$ 计算时间，并且对每个算法都存在某个由 $n$ 个元素组成的输入序列，使它们确实需要 $\Omega(n^2)$ 计算时间。

## 冒泡排序

![冒泡排序算法](https://camo.githubusercontent.com/2ccb6aeadb6f7ab539455635324280e58e858199a251888ad74bce6810a571b8/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d666166636634393939376435313165652e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970)

最简单的排序算法是冒泡排序算法。这种算法的基本思想是，将待排序的记录看成竖着排列的 “气泡”，键值较小的记录比较轻，因而要往上浮。在冒泡排序算法中，要对这个“气泡”序列处理若干遍。所谓处理一遍，就是自底向上检查一遍这个序列，并时刻注意两个相邻的记录的顺序是否正确。如果发现两个相邻记录的顺序不对，即“轻”的记录在下面，就变换它们的位置。显然，处理一遍之后，“最轻”的记录就浮到了最高位置：处理两遍之后，“次轻”的
记录就浮到了次高位置。在进行第二遍处理时，由于最高位置上的记录己是“最轻”记录，所以不必检查。一般地，第 $i$ 遍处理时，不必检查第 $i$ 高位置以上的记录。设待排序的数组段是 `a[l]~a[r]` ，则冒泡排序算法可实现如下。

```c
// element 待排序元素类型
typedef int element;

// Element 待排序元素指针类型
typedef element *Element;

void SortBubble(element a[], int l, int r) {
    for (int i = l; i <= r; i++ ) {
        for (int j = i; j < l; j--) {
            compswap(a[j-1], a[j]);
        }
    }
}
```

上述冒泡排序算法中，待排序元素类型是 `element`，算法根据 Item 类型元素的键值对数组元素 `a[l]~a[r]` 进行排序。算法中用到的关于 `element` 类型变量的一些常用运算，如交换两个元素 A 和 B 值的运算 `swap(A,B)` 等，许多排序算法中都会用到，定义如下。

```c
#define key(A) (A)
// less(A,B) 比较 A 和 B 的键值，等价于 key(A) < key(B)
#define less(A,B) (key(A) < key(B))
// eq(A,B) 等价于 `key(A) == key(B)`
#define eq(A,B) (!less(A,B) && !less(B,A))
// swap(A,B) 交换两个元素 A 和 B 的值；
#define swap(A,B) {element t = A; A = B; B = t;}
// compswap(A,B) 等价于语句 `if (less(B,A)) swap(A,B)` ，即当 `key(B) < key(A)` 时，交换 A 和 B 的值。
#define compswap(A,B) if (less(B,A)) swap(A,B)
```

> 时间复杂度

由于 `compswap` 运算需要 $O(1)$ 计算时间，所以冒泡排序算法的
循环体耗时 $O(1)$ 。由此可知整个算法所需的时间为
$$
\sum_{i=2}^n\sum_{j=0}^{i-2}O(1) =O(\sum_{i=1}^{n-1}\sum_{j=1}^{i}1) = O(n^2)
$$
最坏情况在输入元素序列完全逆序排列时发生。另一方面，即使不需要交换位置，即输入的元素序列己经排好序，算法仍需执行 $n(n-1)/2$ 次元素比较，因此算法至少需要 $\Omega(n^2)$ 计算时间。

## 插入排序

插入排序算法的基本思想是，对数组元素 `a[l]~a[l]` ，经过前 `i-l` 遍处理后，$a[l], a[l+1],...,a[i-l]$ 己排好序。下一遍处理就是要将 $a[i]$ 插入 $a[l], a[l+1],...,a[i-l]$ 的适当位置，使得 $a[l], a[l+1],...a[i]$ 是排好序的序列。要达到这个目的，可以用顺序比较的方法，首先比较 $a[i]$ 和 $a[i-1]$ ，若 $a[i-1] \leq a[i]$ ，则 $a[l], a[l+1],...a[i]$ 已排好序，第 $i$ 遍处理就结束了；否则交换 $a[i-1]$ 与 $a][1]$ 的位 置，继续比较 $a[i-1]$ 和      $a[i-2]$，直到找到某一个位置 $j(1 \leq j \leq i-1)$，使得当 $a[j] \leq a[j+1]$ 时为止。上述元素插入过程由算法             `insert` 来完成。

```c
#include "sort_select.h"

// insert 元素 a[i] 插入 数组 a[l:i]
void insert(element a[], int l, int i) {
    element v = a[i];
    while (i > l && less(v, a[i-1])) {
        a[i] = a[i-1]; i--;
    }
}
```

插入入排序算法通过反复调用 `insert` 来完成排序任务。

```c
#include "sort_select.h"

// SortInsert 插入排序算法
void SortInsert(element a[], int l, int r) {
    for (int i = l + 1; i <= r; i++) {
        insert(a, l, i);
    }
}
```

> 时间复杂度

插入排序算法对固定的 $i$ ， $insert(a, 0, i)$ 在最坏情况下需要 $O(i)$ 计算时间。因此整个插入排序算法所需的时间为
$$
\sum_{i=1}^{n-1}O(i) =O(\sum_{i=1}^{n-1}i) = O(n^2)
$$
最坏情况在输入元素序列完全逆序排列时发生。此时对任意的 $i$ ，算法 `insert` 需要进行 $i$ 次比较和交换。因此在整个插入排序算法中执行的比我利交换次数为 $\sum_{i=1}^{n-1}i=n(n-1)/2$ 。由此可知，在最坏情况下，插入排序算法需要 $\Omega(n^2)$ 计算时间。

## 希尔排序

![希尔排序](https://camo.githubusercontent.com/68a3945dc668bee934f15515e942a2e5c2a6b3871933359cda5432b5cd42820d/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d616363366336663136623039363739342e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970)

选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；



## 选择排序

选择排序算法的基本思想是对待排序的元素序列 `a[l] ~ a[r]` 进行 $r-l$ 遍处理，第 $i$ 遍处理是将 $a[l+i-1], a[l+i],...,a[r]$ 中最小者与 a[l+i-1] 交换位置。这样，经过 $i$ 遍处理之后，较小的 $i$ 个元
素的位置己经是正确的了。确定 $a[i:r]$ 中最小元素下标的算法 `mini` 可表述如下。

```c
// mini 确认 a[i:r] 中的最小元素下标
int mini(element a[], int i, int r) {
    int min = i;
    for (int j = i + 1; j <= r; j++) {
        if (less(a[j], a[min])) {
            min = j;
        }
    }
    return min;
}


```

利用函数 `mini` ，选择排序算法可实现如下。

```c
// SortSelect 选择排序算法
void SortSelect(element a[], int l, int r) {
    for (int i = l; i < r; i++) {
        int j = mini(a, i, r);
        swap(a[i], a[j]);
    }
}
```

> 时间复杂度

选择排序算法的第 $i$ 遍处理是将 $a[i-1], a[i],...,a[n-1]$ 中最小者与 $a[i-1]$ 交换位置。而确定 $a[i-1:n-1]$ 中最小元素下标的算法 `mini` 需要 $O(n-i)$ 计算时间。因此整个算法需要的计算时间为
$$
\sum_{i=1}^{n-1}O(n-i) =O(\sum_{i=1}^{n-1}(n-i)) = O(n^2)
$$
另一方面，对于任何输入序列，选择排序算法总要执行 $n(n-1)/2$ 次元素比较，因此选择排
序算法至少需要 $\Omega(n^2)$ 计算时间。

## 快速排序

事实上，在判定树计算模型下，任何一个基于比较的排序算法都需要 $O(nlogn)$ 计算时间。若能设计一个
需要 $O(nlogn)$ 时间的排序算法，则在渐近的意义上，这个排序算法是最优的。

快速排序算法是基于分治策略的排序算法。其基本思想是，对于输入的子数组 $a[l:r]$，按以下3个步骤进行排序。

- (1) 分解：以 $a[r]$ 为基准元素将 $a[l:r]$ 划分成3段 $a[l:i-1]$ ， $a[i]$ 和 $a[i+1:r]$ ，使得 $a[l:i-1]$ 中任何一个元素小于等于 $a[i]$ ，$a[i+1:r]$ 中任何一个元素大于等于 $a[i]$ 。下标 $i$ 在划分过程中确定。
- (2) 递归求解：通过递归调用快速排序算法分别对 a[l:i-1] 和 a[i+1:r] 进行排序。
- (3) 合并：由于对 $a[l:i-1]$ 和 a[i+1:r] 的排序是就地进行的，所以在 $a[l:i-1]$ 和 $a[i+1:r]$ 都己排好序后不需要执行任何计算， $a[l:r]$ 就己排好序。

基于这个思想，可实现快速排序算法如下。

```c
#include "sort_quick.h"

// SortQuick 快速排序算法
void SortQuick(element a[], int l, int r) {
    if (r <= l) {
        return;
    }
    int i = partition(a, l, r);
    SortQuick(a, l, i - 1); // 对左半段排序
    SortQuick(a, i + 1, r); // 对右半段排序
}
```

对含有 $n$ 个元素的数组 $a[0:n-1]$ 进行快速排序只要调用 `SortQuick(a, 0, n-1)` 即可。
上述算法中的函数 `partition` ，以一个确定的基准元素 $a[r]$ 对子数组 $a[l:r]$ 进行划分，它是快速排序算法的关键。

```c
#include "sort_quick.h"

// partition 元素划分算法
int partition(element a[], int l, int r) {
    int i = l - 1, j = r;
    element v = a[r];
    for (;;) {
        while (less(a[++i], v));
        while (less(v, a[--j])) {
            if (j == l) {
                break;
            }
        }
        if (i >= j) {
            break;
        }
        swap(a[i], a[j]);
    }
    swap(a[i], a[r]);
    return i;
}
```

函数 `partition` 对叫进行划分时，以元素 `v = a[r]` 作为划分的基准，分别从左、右两端开始，扩展两区域  $a[l:r]$ 和 $a[j:r]$ ，使得 $a[l:r]$ 中元素小于或等于 `v` ，而 $a[j:r]$ 中元素大于或等于 `v` 。初始时，`i = l - 1` 且 `j = r` 。

在第7~10行的for 循环体中，下标 $j$ 逐渐减小， $i$ 逐渐增大，直到 $a[i] \ge v \ge a[j]$。若这两个不等式是严格的，则 $a[i]$ 不会是左边区域的元素，而 $a[j]$ 不会是右边区域的元素。此时若 $i \lt j$ ，则交换 $a[i]$ 与 $a[j]$ 的位置，扩展左右两个区域。

for 循环重复至的 $i \ge j$ 时结束。这时 $a[l:r]$ 己被划分成 $a[l:i-1]$ ，$a[i]$ 和 $a[i+1:r]$ ，且满足 a[l:i-1] 中元素不大于 $a[i+1:r]$ 中元素。在两数 `partition` 结束时返回划分点 $i$ 。

事实上，函数 `partitio` 的主要功能就是将小于 `v` 的元素放在原数组的左半部分；而将大于 `v`  ，的元素放在原数组的右半部分。其中，有一些细节需要注意。例如，算法中的下标 $i$ 和 $j$ ；不会超出 $a[l:r]$ 的下标界。另外，在快速排序算法中选取 $a[r]$ 作为基准可以保证算法正常结束。

> 时间复杂度

对于输入序列 a[l:r]，函数 `partition` 的计算时间显然为 O(r-l-1) 。
对含有 n 个元素的数组 a[0:n-1] 进行快速排序的运行时间与划分是否对称有关，其最坏情况发生在划分过程中产生的两个区域分别包含  $n-1$ 个元素和 $1$ 个元素的时候。由于函数 `partition` 的计算时间为 $O(n)$ ，所以若两数 `partition` 的每一步都出现这种不对称划分，则其时间复杂性 $T(n)$ 满足
$$
T(n) = 
\begin{cases}
O(1), & n \leq 1\\
T(n-1)+O(n), & n \gt 1
\end{cases}
$$
解此递归方程可得 $T(n) = O(n^2)$

在最好情况下，每次划分所取的基准都恰好为中值，即每次划分都产生两个大小为 $n/2$ 的区域，此时，两数`partition` 的计算时间 $T(n)$ 满足
$$
T(n) = 
\begin{cases}
O(1), & n \leq 1\\
2T(n/2)+O(n), & n \gt 1
\end{cases}
$$
其解为 $T(n) = O(nlogn)$ 。
可以证明，快速排序算法在平均情况下的时间复杂性也是 $O(nlogn)$ ，这在基于比较的排序算法类中算是快速的了，快速排序算法也因此而得名。

## 合并排序

合并排序算法是用分治策略实现对 $n$ 个元素排序的算法。其基本思想是：当 $n = 1$ 时终止排序，否则将待排序元素分成大小大致相同的两个子集，分别对两个子集进行排序，最终将排好序的子集合并为所求的排好序的集合。

合并排序算法可递归地描述如下。

```c
#include "sort_merge.h"

// mergeAB 合并 a[l:m] 和 a[m+1:r] 到 b[l:r]
void mergeAB(element a[], element b[], int l, int m, int r) {
    int i = l, j = m + 1, k = 1;
    while ((i <= m) && (j <= r)) { // 取两段中较小元素到数组b中
        if (less(a[i], a[j])) {
            b[k++] = a[i++];
        } else {
            b[k++] = a[j++];
        }
    }
  	// 处理剩余元素
    if (i > m) {
        for (i = j; i < r; i++) {
            b[k++] = a[i];
        }
    } else {
        for (; i < m; i++) {
            b[k++] = a[i];
        }
    }
}
```

其中，在第7行由算法 `mergeAB` 把两个排好序的数组段合并到一个新的数组 $b$ 中，然后在第8行由函数 `copy` 将合并后的数组段复制回数组 $a$ 中。

```c
#include "sort_merge.h"

// copy
void copy(element b[], element a[], int l, int r) {
    for (int i = l; i <= r; i++) {
        a[i] = b[i];
    }
}

// SortMerge 合并排序算法
void SortMerge(element a[], int l, int r) {
    int m = (r + l) / 2; // 取中点
    if (r <= l) {
        return;
    }
    element b[] = {};
    SortMerge(a, l, m); // 对左半段排序
    SortMerge(a, m + 1, r); // 对右半段排序
    mergeAB(a, b, l, m, r); // 合并到数组b
    copy(b, a, l, r); // 复制回数组a
}
```

`mergeAB` 和 `copy` 显然可在 $O(n)$ 时间内完成，因此合并排序算法对八个元素进行排序，在最坏情况下所需的计算时间 $T(n)$ 满足
$$
T(n) =
\begin{cases}
O(1), & n \leq 1  \\
2T(\frac{n}{2})+O(n), & n \gt 1
\end{cases}
$$


解此递归方程可知 $T(n)=O(nlogn)$ 。由于排序问题的计算时间下界为 $\Omega(nlogn)$，所以合并排序算法是一个渐近最优算法。

## 堆排序



## 计数排序



## 桶排序



## 基数排序
