---
title: "第四章 队列"
date: 2021-12-31T17:17:17+08:00
draft: false
---

<!--more-->

## 队列的基本概念

队列是另一种特殊的表,这种表只在表首(也称为队首)进行删除操作,只在表尾(也称为队尾)进行插入操作。由于队列的修改是按先进先出的规则进行的,所以队列又称为先进先出( First In First Out)表,简称FIFO表。

![image-20211231145839218](/data_structure/4-1.png)

假设队列为 $a(1),a(2), ... , a(n)$ ，那么 $a(1)$ 就是队首元素， $a(n)$ 为队尾元素。队列中的元素是按 $a(1),a(2), ... , a(n)$  的顺序进入的，退出队列也只能按照这个次序依次退出。也就是说,只有在 $a(1)$ 离开队列之后， $a(2)$ 才能退出队列。只有在 $a(1),a(2), ... , a(n)$ 都离开队列之后， $a(n)$ 才能退出队列。图4-1所示为队列示意图

队列支持的6个基本运算如下。

- (1) Queueempty(Q):测试队列Q是否为空。
- (2) Queuefull(Q):测试队列Q是否已满。 
- (3) Queuefirst():返回队列Q的队首元素。
- (4) Queue Last(O):返回队列Q的队尾元素。
- (5) Enterqueue(x,D:在队列Q的队尾插入元素x。
- (6) Deletequeue(Q):删除并返回队列Q的队首元素。

## 用指针实现队列

### queue_pointer.h

```c
// queuePointerElement 队列元素类型
typedef int queuePointerElement;

// QueuePointerElement 队列元素指针类型
typedef queuePointerElement *QueuePointerElement;

// QueuePointerNode 队列结点指针类型
typedef struct queuePointerNode *QueuePointerNode;

// queuePointerNode 队列
struct queuePointerNode {
    QueuePointerElement Element; // 队列元素
    QueuePointerNode Next; // 指向下一个结点的指针
} queuePointerNode;

// QueuePointer 队列指针类型
typedef struct queuePointer *QueuePointer;

// queuePointer 队列指针结构
typedef struct queuePointer {
    QueuePointerNode Front; // 队首指针
    QueuePointerNode Rear; // 队尾指针
} queuePointer;

#ifndef DATA_STRUCT_QUEUE_POINTER_H
#define DATA_STRUCT_QUEUE_POINTER_H

// QueuePointerElementShow 输出队列元素
void QueuePointerElementShow(queuePointerElement element);

// NewQueuePointerNode 产生一个新队列结点
QueuePointerNode NewQueuePointerNode();

// QueuePointerInit 通过将队首指针 Front 和队尾指针 Rear 置为空指针,创建一个空队列。
QueuePointer QueuePointerInit();

// QueuePointerEmpty 检测 Front 是否为空指针
int QueuePointerEmpty(QueuePointer queue);

// QueuePointerFirst 返回队列 queue 的队首结点中的元素
QueuePointerElement QueuePointerFirst(QueuePointer queue);

// QueuePointerLast 返回队列 queue 的队尾结点中的元素
QueuePointerElement QueuePointerLast(QueuePointer queue);

// QueuePointerEnter 先为元素 node 创建一个新结点,然后修改队列 queue 的队尾结点指针,在队尾插入新结点,使新结点成为新队尾结点。
void QueuePointerEnter(QueuePointer queue, QueuePointerElement element);

// QueuePointerDelete 先将队首元素存于 element 中,然后修改队列 queue 的队首结点指针使其指向队首结点的下一个结点,从而删除队首结点; 最后返回 element
QueuePointerElement QueuePointerDelete(QueuePointer queue);

#endif //DATA_STRUCT_QUEUE_POINTER_H
```

### queue_pointer.c

```c
#include <stdio.h>
#include <stdlib.h>

#include "queue_pointer.h"

// QueuePointerElementShow 输出队列元素
void QueuePointerElementShow(queuePointerElement element) {
    printf("%d", element);
}

// NewQueuePointerNode 产生一个新队列结点
QueuePointerNode NewQueuePointerNode() {
    return (QueuePointerNode) malloc(sizeof(QueuePointerNode));
}

// QueuePointerInit 通过将队首指针 Front 和队尾指针 Rear 置为空指针,创建一个空队列。
QueuePointer QueuePointerInit() {
    QueuePointer queue = (QueuePointer) malloc(sizeof *queue);
    queue->Front = queue->Rear = 0;
    return queue;
}

// QueuePointerEmpty 检测 Front 是否为空指针
int QueuePointerEmpty(QueuePointer queue) {
    return queue->Front == NULL;
}

// QueuePointerFirst 返回队列 queue 的队首结点中的元素
QueuePointerElement QueuePointerFirst(QueuePointer queue) {
    if (QueuePointerEmpty(queue)) { // 判断队列是否为空
        exit(1);
    }
    return queue->Front->Element;
}

// QueuePointerLast 返回队列 queue 的队尾结点中的元素
QueuePointerElement QueuePointerLast(QueuePointer queue) {
    if (QueuePointerEmpty(queue)) { // 判断队列是否为空
        exit(1);
    }
    return queue->Rear->Element;
}

// QueuePointerEnter 先为元素 node 创建一个新结点,然后修改队列 queue 的队尾结点指针,在队尾插入新结点,使新结点成为新队尾结点。
void QueuePointerEnter(QueuePointer queue, QueuePointerElement element) {
    QueuePointerNode node = NewQueuePointerNode();
    node->Element = element;
    node->Next = 0;
    if (queue->Front == NULL) { // 队列不为空
        queue->Rear->Next = node;
    } else {
        queue->Front = node; // 队列为空
    }
    queue->Rear = node;
}

// QueuePointerDelete 先将队首元素存于 element 中,然后修改队列 queue 的队首结点指针使其指向队首结点的下一个结点,从而删除队首结点; 最后返回 element
QueuePointerElement QueuePointerDelete(QueuePointer queue) {
    if (QueuePointerEmpty(queue)) { // 判断队列是否为空
        exit(1);
    }
    QueuePointerElement element = queue->Front->Element; // 将队首元素存于 element 中
    QueuePointerNode node = queue->Front; // 将队首结点存于 node 中
    queue->Front = queue->Front->Next; // 修改队列 queue 的队首结点指针使其指向队首结点的下一个结点
    free(node); // 回收队首结点内存
    node = NULL;
    return element;
}
```

## 用循环数组实现队列

### queue_cyclic_array.h

```c

// queueCyclicArrayElement 队列元素类型
typedef int queueCyclicArrayElement;

// QueueCyclicArrayElement 队列元素指针类型
typedef queueCyclicArrayElement *QueueCyclicArrayElement;

typedef struct queueCyclicArray *QueueCyclicArray;

typedef struct queueCyclicArray {
    int MaxSize; // 循环数组大小
    int Front; // 队首游标
    int Rear; // 队尾游标
    QueueCyclicArrayElement *Queue; // 循环数组
} queueCyclicArray;

#ifndef DATA_STRUCT_QUEUE_CYCLIC_ARRAY_H
#define DATA_STRUCT_QUEUE_CYCLIC_ARRAY_H

// QueueCyclicArrayInit 为队列分配一个容量为 size 的循环数组 queue ,并将队首游标 Font 和队尾游标 Rear 均置为0,创建一个空队列。
QueueCyclicArray QueueCyclicArrayInit(int size);

// QueueCyclicArrayEmpty 通过检测队列 queue 的队首游标 Front 与队尾游标 Rear 是否重合来判断队列 queue 是否为空队列。
int QueueCyclicArrayEmpty(QueueCyclicArray queue);


// QueueCyclicArrayFull 通过检测在队列Q的队尾插入一个元素后队首游标 Front 与队尾游标 Rear 是否重合来判断队列 queue 是否为满队列
int QueueCyclicArrayFull(QueueCyclicArray queue);

// QueueCyclicArrayElement 返回队列Q的队首元素。由于队首游标 Front 指向队首元素的前一位置,所以队首元素在循环数组 queue 中的下标是 (Front+1) % maxsize。
QueueCyclicArrayElement QueueCyclicArrayFirst(QueueCyclicArray queue);

// QueueCyclicArrayLast 返回存储在队列 queue 的 queue[Rear] 中的队尾元素。
QueueCyclicArrayElement QueueCyclicArrayLast(QueueCyclicArray queue);

// QueueCyclicArrayEnter 先计算出在循环的意义下队列 queue 的队尾元素在循环数组 Queue 中的下一位置 (Rear+1) % MaxSize 然后在该位置插入元素
void QueueCyclicArrayEnter(QueueCyclicArray queue, QueueCyclicArrayElement element);


// QueueCyclicArrayDelete 先将队列 queue 的队首游标 Front 修改为在循环的意义下队首元素在循环数组 Queue 中的下一位置(Front)% MaxSize,然后返回该位置的元素,即队首元素。
QueueCyclicArrayElement QueueCyclicArrayDelete(QueueCyclicArray queue);

#endif //DATA_STRUCT_QUEUE_CYCLIC_ARRAY_H
```

### queue_cyclic_array.c

```c
#include <stdio.h>
#include <stdlib.h>

#include "queue_cyclic_array.h"

// QueueCyclicArrayInit 为队列分配一个容量为 size 的循环数组 queue ,并将队首游标 Font 和队尾游标 Rear 均置为0,创建一个空队列。
QueueCyclicArray QueueCyclicArrayInit(int size) {
    QueueCyclicArray queue = (QueueCyclicArray) malloc(sizeof *queue);
    queue->Queue = (QueueCyclicArrayElement *) malloc(size * sizeof(QueueCyclicArrayElement));
    queue->MaxSize = size;
    queue->Front = queue->Rear = 0;
    return queue;
}

// QueueCyclicArrayEmpty 通过检测队列 queue 的队首游标 Front 与队尾游标 Rear 是否重合来判断队列 queue 是否为空队列。
int QueueCyclicArrayEmpty(QueueCyclicArray queue) {
    return queue->Front == queue->Rear;
}


// QueueCyclicArrayFull 通过检测在队列Q的队尾插入一个元素后队首游标 Front 与队尾游标 Rear 是否重合来判断队列 queue 是否为满队列
int QueueCyclicArrayFull(QueueCyclicArray queue) {
    return (((queue->Rear + 1) % queue->MaxSize == queue->Front) ? 1 : 0);
}

// QueueCyclicArrayElement 返回队列Q的队首元素。由于队首游标 Front 指向队首元素的前一位置,所以队首元素在循环数组 queue 中的下标是 (Front+1) % maxsize。
QueueCyclicArrayElement QueueCyclicArrayFirst(QueueCyclicArray queue) {
    if (QueueCyclicArrayEmpty(queue)) { // 判断队列是否为空
        exit(1);
    }
    return queue->Queue[(queue->Front + 1) % queue->MaxSize];
}

// QueueCyclicArrayLast 返回存储在队列 queue 的 queue[Rear] 中的队尾元素。
QueueCyclicArrayElement QueueCyclicArrayLast(QueueCyclicArray queue) {
    if (QueueCyclicArrayEmpty(queue)) { // 判断队列是否为空
        exit(1);
    }
    return queue->Queue[queue->Rear];
}

// QueueCyclicArrayEnter 先计算出在循环的意义下队列 queue 的队尾元素在循环数组 Queue 中的下一位置 (Rear+1) % MaxSize 然后在该位置插入元素
void QueueCyclicArrayEnter(QueueCyclicArray queue, QueueCyclicArrayElement element) {
    if (QueueCyclicArrayFull(queue)) { // 判断队列是否为满
        exit(1);
    }
    queue->Rear = (queue->Rear + 1) % queue->MaxSize;
    queue->Queue[queue->Rear] = element;
}


// QueueCyclicArrayDelete 先将队列 queue 的队首游标 Front 修改为在循环的意义下队首元素在循环数组 Queue 中的下一位置(Front)% MaxSize,然后返回该位置的元素,即队首元素。
QueueCyclicArrayElement QueueCyclicArrayDelete(QueueCyclicArray queue) {
    if (QueueCyclicArrayEmpty(queue)) { // 判断队列是否为空
        exit(1);
    }
    queue->Front = (queue->Front + 1) % queue->MaxSize;
    return queue->Queue[queue->Front];
}
```

