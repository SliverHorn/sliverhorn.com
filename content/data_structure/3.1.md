---
title: "第三章 栈 练习"
date: 2021-12-30T17:17:17+08:00
draft: false
---

<!--more-->

1. 限定仅在表尾进行插入和删除操作的线性表称为 ([^1])，它的修改是按 ([^1]) 的原则进行的。

2. 若进栈序列为 $a, b, c$ ，则通过入栈操作可能得到的 $a, b, c$  出栈的不同排列个数 ([^2])。

A. 4

B. 5

C. 6

D. 7

> $n$ 不同元素进栈, 出栈元素不同排列的个数为 $\frac {1}{n+1}C_{2n}^{n}$

3. 向顺序栈中压入新元素，应当 ([^3])。

A. 先移动栈顶指针，再存入元素

B. 先存入元素，再移动栈顶指针

C. 先后次序无关紧要

D. 同时进行

4. 一个栈的入栈序列是 $1, 2, 3, 4, 5$ ，则栈的不可能输出序列是  ([^4])。

A. 43512

B. 54321

C. 45321

D. 12345

5. 栈内元素从栈底到栈顶依次为  ([^5])。

```c
ListStack myStack;
myStack.push("A");
myStack.push("K");
myStack.push("D");
myStack.pop();
myStack.push("H");
myStack.push("K");
myStack.pop();
myStack.pop();
myStack.push("D");
```

6. 若栈采用顺序存储方式存储，现两栈共享空间 $V[1...m]$ ， $top1$ ， $top2$ ，分别代表第一和第二个栈的栈顶，栈 $1$ 的底在 $V[1]$ ，栈 $2$ 的底在 $V[2]$ ，则栈满的条件是 ([^6])。

A. $|top2 - top1| = 0$

B. $top1 + 1 = top2$

C. $top1 + top2 = m$

D. $top1 = top2$

7. 链栈对比顺序栈主要优点在于 ([^7])。

A. 通常不会出现栈满的情况

B. 通常不会出现栈空的情况

C. 插入操作更加方便

D. 删除操作更加方便

8. 将一个递归算法改为对应的非递归算法时，通常需要使用

A. 栈 

B. 队列 

C. 循环队列 

D. 优先队列

9. 栈的 $push$ 和 $pop$ 操作均在 ([^9]) 进行

A. 栈顶位置

B. 栈底位置

C. 任意位置

D. 中间位置

10. 栈又称先进先出的线性表  ([^10])。
11. 若已知一个栈的入栈序列是 $1, 2, 3,...,n$  ， 其输出序列为 $P_1, P_2, P_3,...P_n$ ， 若 $P_1 = n$ ，则 $P_i$ 为  ([^11])。

A. `i`

B. `n - i`

C. `n-i+1`

D. 不确定

12. 由两个栈共享一个向量空间的好处是  ([^12])。

A.  减少存取时间，降低下溢发生的概率

B. 节省存储空间，降低上溢发生的概率

C. 减少存取时间，降低上溢发生的概率

D. 节省存储空间，降低下溢发生的概率

13. 设栈 $S$ 和队列 $Q$ 的初始状态为空，元素 $e_1, e_2, e_3, e_4, e_5, e_6$ 依次通过栈 $S$ ，一个元素进栈后即进队列 $Q$ ，若六个元素出栈的序列是 $e_2, e_4, e_3, e_6, e_5, e_1$ ，则栈S的容量至少应该是 ([^13]) 。
14. 解决括号匹配问题，最适合使用 ([^14]) 数据结构。

A. 堆

B. 栈

C. 队列

D.二叉树

---

[^1]: 栈，后进先出
[^2]: B. 5
[^3]: A. 先移动栈顶指针，再存入元素
[^4]: A. 43512
[^5]: AKD
[^6]: B. $top1 + 1 = top2$
[^7]: A. 通常不会出现栈满的情况
[^8]:A. 栈
[^9]: A. 栈顶位置
[^10]: 错误。栈是先进后出，后进先出。
[^11]: C. `n-i+1`
[^12]: B. 节省存储空间，降低上溢发生的概率
[^13]: 3
[^14]: B. 栈



