---
title: "第二章 线性表"
date: 2021-12-28T17:17:17+08:00
draft: false
---

<!--more-->

## 线性表的类型定义

线性表是具有相同数据类型的 $n(n\ge0)$ 个数据元素的有限序列。

用 $L$ 命名线性表，则其一般表示为
$$
L = (a_1, a_2, ... a_i, a_{i+1}, ... a_n)
$$

> 除第一个元素外，每个元素有且仅有一个直接前驱。
> 除最后一个元素外，每个元素有且仅有一个直接后继。

| 序号 | 函数                                                         | 函数作用                                                    |
| :--: | :----------------------------------------------------------- | :---------------------------------------------------------- |
|  1   | `int SequenceTableInit(SequenceTable *sequenceTable);`       | 初始化表。构造一个空的线性表。                              |
|  2   | `int SequenceTableLength(SequenceTable sequenceTable);`      | 求表长。返回线性表L的长度，即L中数据元素的个数。            |
|  3   | `int SequenceTableLocate(SequenceTable sequenceTable, ElemType elemType);` | 按值查找操作。获取表L中查找具有给定关键宇值的元素。         |
|  4   | `int SequenceTableGet(SequenceTable sequenceTable, int index);` | 按位查找操作。获取表L中第i个位置的元素的值。                |
|  5   | `bool SequenceTableInsert(SequenceTable *sequenceTable, int index, ElemType elem);` | 插入操作。在表L中的第i个位置上插入指定元素e。               |
|  6   | `bool SequenceTableDelete(SequenceTable *sequenceTable, int index, ElemType *elemType);` | 删除操作。州除表L中第i个位置的元素，并用e返回删除元素的值。 |
|  7   | `void SequenceTablePrint(SequenceTable sequenceTable)`       | 输出操作。按前后顺序输出线性表工的元素值。                  |
|  8   | `bool SequenceTableEmpty(SequenceTable sequenceTable)`       | 判空操作。                                                  |
|  9   | `void SequenceTableDestroy(SequenceTable *sequenceTable)`    | 销毁操作。                                                  |

```c
// 顺序表

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define SequenceTableSize 50;

typedef int ElemType;

typedef struct {
    ElemType *Data;
    int MaxSize;
    int Length;
} SequenceTable;

// SequenceTableInit 顺序表 初始化
int SequenceTableInit(SequenceTable *sequenceTable) {
    int size = sizeof(ElemType) * SequenceTableSize
    sequenceTable->Data = (ElemType *) malloc(size);
    if (sequenceTable->Data == NULL) { //内存分配失败，存储空间不够
        printf("内存分配失败!");
        return 0;
    }
    sequenceTable->Length = 0; // 表示顺序表为空
    sequenceTable->MaxSize = SequenceTableSize; // 表示顺序表里，最大存储单元个数
    return 1;
}

// SequenceTableLength 顺序表 长度
int SequenceTableLength(SequenceTable sequenceTable) {
    return sequenceTable.Length;
}

// SequenceTableInsert 顺序表 插入
bool SequenceTableInsert(SequenceTable *sequenceTable, int index, ElemType elem) {
    if (index < 1 || index > sequenceTable->Length + 1) { // 判断 index 的范围是否有效
        return false;
    }

    for (int i = sequenceTable->Length; i >= index; i--) {
        sequenceTable->Data[i] = sequenceTable->Data[i - 1];
    }
    sequenceTable->Data[index - 1] = elem; //在位置 index 处放入 elem
    sequenceTable->Length++; // 顺序表长度加1
    return true;
}

// SequenceTableDelete 顺序表 删除
bool SequenceTableDelete(SequenceTable *sequenceTable, int index, ElemType *elemType) {
    if (index < 1 || index > sequenceTable->Length) { // 判断 index 的范围是否有效
        return false;
    }

    elemType = &sequenceTable->Data[index - 1]; // 将被删除的元素赋给 elemType
    for (int i = index; i < sequenceTable->Length; i++) { // 将第 index 个位置后的元素后移
        sequenceTable->Data[i - 1] = sequenceTable->Data[i];
    }
    sequenceTable->Length--; // 顺序表长度减1

    return true;
}

// SequenceTableLocate 顺序表 定位
int SequenceTableLocate(SequenceTable sequenceTable, ElemType elemType) {
    for (int i = 0; i < sequenceTable.Length; i++) {
        if (sequenceTable.Data[i] == elemType) {
            return i + 1; // 下标为 i 的元素值等于 elemType，返回其位序
        }
    }
    return 0;
}

// SequenceTableGet 顺序表 按位查找操作
int SequenceTableGet(SequenceTable sequenceTable, int index) {
    if (index < 1 || index > sequenceTable.Length) { // 判断 index 的范围是否有效
        return 0;
    }
    return sequenceTable.Data[index - 1];
}

// SequenceTableEmpty 顺序表 判空操作
bool SequenceTableEmpty(SequenceTable sequenceTable) {
    if (sequenceTable.Length == 0) {
        return true;
    }
    return false;
}

// SequenceTablePrint 顺序表 输出操作。按前后顺序输出顺序表的元素值。
void SequenceTablePrint(SequenceTable sequenceTable) {
    if (SequenceTableEmpty(sequenceTable) == true) {
        return;
    }
    for (int i = 0; i < sequenceTable.Length; i++) {
        printf("index: %d, value: %d", i, *sequenceTable.Data);
    }
}

// SequenceTableDestroy 顺序表 销毁操作
void SequenceTableDestroy(SequenceTable *sequenceTable) {
    free(sequenceTable);
    sequenceTable = NULL;
}

// SequenceTableMerge 顺序表 合并
bool SequenceTableMerge(SequenceTable sequenceTable1, SequenceTable sequenceTable2, SequenceTable *newSequenceTable) {
    if (sequenceTable1.Length + sequenceTable2.Length > newSequenceTable->MaxSize) {
        return false;
    }
    int i = 0, j = 0, k = 0;
    while (i < sequenceTable1.Length && j < sequenceTable2.Length) {
        if (sequenceTable1.Data[i] <= sequenceTable2.Data[j]) {
            newSequenceTable->Data[k++] = sequenceTable1.Data[i++];
        } else {
            newSequenceTable->Data[k++] = sequenceTable2.Data[i++];
        }
    }

    while (i < sequenceTable1.Length) {
        newSequenceTable->Data[k++] = sequenceTable1.Data[i++];
    }

    while (i < sequenceTable2.Length) {
        newSequenceTable->Data[k++] = sequenceTable2.Data[i++];
    }

    newSequenceTable->Length = k;
    return true;
}
```

## 顺序表的结构

线性表的顺序存储称为顺序表，它是由一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。

顺序表的特点:

- 顺序表最主要的特点是随机存取，即通过首地址和元素序号可在时间 $O(1)$ 内找到指定的元素。
- 顺序表的存储密度高，每个结点只存储数据元素。
- 顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。

