---
title: "第二章 线性表"
date: 2021-12-27T17:17:17+08:00
draft: false

---

<!--more-->

## 表的基本概念

- 定义

表，或称线性表，是一种非常灵便的结构，可以根据需要改变表的长度，也可以在表中任何位置对元素（Element）进行访问、插入或删除等操作。另外，还可以将多个表连接成一个表，或把一个表拆分成多个表。表结构在信息检索、程序设计语言的编译等许多方面有广泛应用。

- 数学模型

表是由 n 个同一类型的元素 a(l),o(2)，a(n组成的有限序列。其中，元素的个数n定义为表的长度。当n=0时称为空表。当n≥1时，称元素 a(位于该表的第化个位置，或称al是表中第 6个元素，人=12,
•n。根据各元素在表中的不同位置可以定义它们在表中的前后次序。称元素 a(在元素ah+1之前，或alo是aht1)的前驱，人-1,2,…1-1。同时，也称元素 a+1)在元素a之后，或alht1是a(的后继。

- 逻辑特征

非空的表有且仅有一个开始元素 a1，该元素没有前驱，而有一个后继 (2)：有且仅有-个结束元素 an，结束元素没有后继，而有一个前驱 arD;其余的元素 ak(2<从<n-1)都有一个前驱和一个后继。表元素之间的逻辑关系就是上述的邻接关系。由于这种关系是线性的，所以表是一种线性结构，有时也称为线性表。

| 函数                 | 函数说明                                                     |
| :------------------- | :----------------------------------------------------------- |
| `ListEmpty(L)`       | 测试表 $L$ 是否为空                                          |
| `ListLength(L)`      | 表 $L$ 的长度                                                |
| `ListLocate(x, L)`   | 元素x在表工中的位置若 $x$ 在表 $L$ 中重复出现多次，则返回最前面的 $x$ 的位置 |
| `ListRetrieve(k, L)` | 返回表 $L$ 的位置大处的元素。表中没有位置 $k$ 时，该运算无定义。 |
| `Listinsert(x, L)`   | 在表 $L$ 的位置人之后插入元素 $x$ ，并将原来占据该位置的元素及其后面的元素都向后推移一个位置。 |
| `ListDelete(k, L)`   | 从表 $L$ 中删除位置 $k$ 处的元素，并返回被删除的元素。       |
| `PrintList(L)`       | 将表 $L$ 中所有元素按位置的先后次序打印输出                  |

## 用数组实现表

| 函数                                                         | 函数说明                                     | 时间复杂度                                               |
| ------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------------------- |
| `TableArray TableArrayInit(int size);`                       | 表结构初始化                                 | ~                                                        |
| `int TableArrayEmpty(TableArray table);`                     | 测试表 table 是否为空                        | $O(1)$                                                   |
| `int TableArrayLength(TableArray table);`                    | 输出表 table 的表长                          | $O(1)$                                                   |
| `element TableArrayRetrieve(TableArray table, int index);`   | 返回表 table 的位置 index 处的元素           | $O(1)$                                                   |
| `int TableArrayLocate(TableArray table, element element);`   | 元素 element 在表 table 的位置               | $O(n)$                                                   |
| `void TableArrayInsert(TableArray table, element element, int index);` | 在表 table 的位置 index 之后插入元素 element | 最好的情况下需要 $O(1)$ ， <br />最坏的情况下需要 $O(n)$ |
| `element TableArrayDelete(TableArray table, int index);`     | 从表 table 中删除位置 index 处的元素         | 最好的情况下需要 $O(1)$ ， <br />最坏的情况下需要 $O(n)$ |
| `void TableArrayPrint(TableArray table);`                    | 按位置次序输出表 table 中的元素              | $O(n)$                                                   |
| `void TableArrayFree(TableArray table);`                     | 释放动态分配的空间                           | ~                                                        |

具体实现代码

```c
#include <stdlib.h>

#include "table.h"
#include "table_array.h"

// TableArrayInit 表结构初始化
TableArray TableArrayInit(int size) {
    TableArray table = (TableArray) malloc(sizeof *table);
    table->Table = (element *) malloc(size * sizeof(element));
    table->MaxSize = size;
    table->Length = 0;
    return table;
}

// TableArrayEmpty 测试表 table 是否为空
int TableArrayEmpty(TableArray table) {
    return table->Length == 0;
}

// TableArrayLength 输出表 table 的表长
int TableArrayLength(TableArray table) {
    return table->Length;
}

// TableArrayRetrieve 返回表 table 的位置 index 处的元素
element TableArrayRetrieve(TableArray table, int index) {
    if (index < 1 || index > table->Length) {
        exit(1);
    }
    return table->Table[index-1];
}

// TableArrayLocate 元素 element 在表 table 的位置
int TableArrayLocate(TableArray table, element element) {
    for (int i = 0; i < table->Length; ++i) {
        if (table->Table[i] == element) {
            return ++i;
        }
    }
    return 0;
}

// TableArrayInsert 在表 table 的位置 index 之后插入元素 element
void TableArrayInsert(TableArray table, element element, int index) {
    if (index < 0 || index > table->Length) {
        exit(1);
    }
    for (int i = table->Length - 1; i >= index; i--) {
        table->Table[i + 1] = table->Table[i];
    }
    table->Table[index] = element;
    table->Length++;
}

// TableArrayDelete 从表 table 中删除位置 index 处的元素
element TableArrayDelete(TableArray table, int index) {
    if (index < 0 || index > table->Length) {
        exit(1);
    }
    element element = table->Table[index - 1];
    for (int i = index; i < table->Length; i++) {
        table->Table[i - 1] = table->Table[i];
    }
    table->Length--;
    return element;
}

// TableArrayPrint 按位置次序输出表 table 中的元素
void TableArrayPrint(TableArray table) {
    for (int i = 0; i < table->Length; ++i) {
        ElementShow(table->Table[i]);
    }
}

// TableArrayFree 释放动态分配的空间
void TableArrayFree(TableArray table) {
    free(table->Table);
    free(table);
    table = NULL;
}
```

